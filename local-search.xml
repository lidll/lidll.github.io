<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>(⌨Java) 线程池基础常识</title>
    <link href="/2024/07/05/%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/05/%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="线程池的基础常识"><a href="#线程池的基础常识" class="headerlink" title="线程池的基础常识"></a>线程池的基础常识</h4><h5 id="1-ThreadPoolExecutor有哪些常用的方法"><a href="#1-ThreadPoolExecutor有哪些常用的方法" class="headerlink" title="1. ThreadPoolExecutor有哪些常用的方法?"></a>1. ThreadPoolExecutor有哪些常用的方法?</h5><ul><li>submit()&#x2F;execute(): 执行线程池</li><li>shutdown()&#x2F;shutdownNow(): 终止线程 </li><li>isShutdown(): 线程池是否终止</li><li>getActiveCount(): 正在运行的线程数</li><li>getCorePoolSize(): 核心线程数</li><li>getMaximumPoolSize(): 最大线程数</li><li>getQueue(): 获取线程池中的任务队列</li><li>allowCoreThreadTimeOut(boolean): 设置空闲时是否回收核心线程</li></ul><h5 id="2-submit-和execute-的区别"><a href="#2-submit-和execute-的区别" class="headerlink" title="2. submit()和execute()的区别"></a>2. submit()和execute()的区别</h5><p>两者功能相同,都是用来执行runnable任务, submit()可以使用Future接收线程池执行的返回值,而execute()不行</p><h5 id="3-shutdown-和shutdownNow-的区别"><a href="#3-shutdown-和shutdownNow-的区别" class="headerlink" title="3. shutdown()和shutdownNow()的区别"></a>3. shutdown()和shutdownNow()的区别</h5><p>shutdown()会让线程池不在接收任务,但是会执行完正在运行且在队列中的任务,不会报错</p><p>shutdownNow()会让线程池立即停止任务,如果阻塞队列中还有任务,会就抛出异常InterruptedException</p><h5 id="4-线程池的工作原理"><a href="#4-线程池的工作原理" class="headerlink" title="4. 线程池的工作原理"></a>4. 线程池的工作原理</h5><p>提交任务后,先定义核心线程数以内个数的线程运行,如果任务超过核心线程数,则会将任务加入阻塞队列,如果阻塞队列满了,就会开启最大线程数以内个数的线程去执行任务.如果任务超过了最大线程数.则会执行拒绝策略.</p><h5 id="5-线程池中核心线程数大小应该怎么设置"><a href="#5-线程池中核心线程数大小应该怎么设置" class="headerlink" title="5. 线程池中核心线程数大小应该怎么设置?"></a>5. 线程池中核心线程数大小应该怎么设置?</h5><ul><li><p>CPU密集型任务 &gt; 核心线程数 &#x3D; CPU核心数 + 1</p><p>原因: 避免cpu过度切换导致性能下降</p></li><li><p>IO密集型任务 &gt; 核心线程数 &#x3D; CPU核心数*2</p><p>原因: 像 MySQL 数据库、文件的读写、网络通信等任务，这类任务不会特别消耗 CPU 资源，但是 IO 操作比较耗时，会占用比较多时间。</p></li><li><p>线程的平均工作时间所占比例越高，就需要越少的线程；线程的平均等待时间所占比例越高，就需要越多的线程；</p></li></ul><h5 id="6-线程池为什么需要阻塞队列"><a href="#6-线程池为什么需要阻塞队列" class="headerlink" title="6. 线程池为什么需要阻塞队列?"></a>6. 线程池为什么需要阻塞队列?</h5><ul><li>因为线程若是无限制的创建,可能会导致内存占用过多而产生OOM,并且造成cpu过度切换.</li><li>创建线程的消耗较高.</li></ul><h5 id="7-线程池为什么要使用阻塞队列而不使用非阻塞队列"><a href="#7-线程池为什么要使用阻塞队列而不使用非阻塞队列" class="headerlink" title="7. 线程池为什么要使用阻塞队列而不使用非阻塞队列?"></a>7. 线程池为什么要使用阻塞队列而不使用非阻塞队列?</h5><p>阻塞队列可以保证任务中没有任务时阻塞获取任务的线程,使得线程进入wait状态,释放cpu资源.</p><p>当队列中有任务时才唤醒对应线程从队列中取出消息进行执行.</p><p>使得线程不至于一直占用cpu资源</p><p>线程执行完任务后通过循环再次从任务队列中缺处任务进行执行</p><h5 id="8-线程池的状态"><a href="#8-线程池的状态" class="headerlink" title="8. 线程池的状态"></a>8. 线程池的状态</h5><p>通过获取线程池状态,可以判断线程池是否是运行状态,可否添加新的任务以及优雅的关闭线程池等.</p><p>running: 线程池的初始化状态,可以添加待执行的任务.</p><p>shutdown: 线程池处于待关闭状态,不接受新任务仅处理已经接收的任务.</p><p>stop: 线程池立即关闭,不接受新的任务,放弃缓存队列中的任务并且中断正在处理的任务.</p><p>tiding: 线程池自主整理状态,调用terminated()方法进行线程池整理.</p><p>terminated: 线程池终止状态</p><h5 id="9-线程池中的复用原理"><a href="#9-线程池中的复用原理" class="headerlink" title="9. 线程池中的复用原理"></a>9. 线程池中的复用原理</h5><p>线程池奖线程和任务进行解耦,线程是线程,任务是任务,摆脱了之前通过Thread创建线程时的一个线程必须对应一个任务的限制.</p><p>在线程池中,同一个线程可以从阻塞队列中不断获取薪任务来执行,其核心原理在于线程池对Thread进行了封装,并不是每次执行任务都会调用Thread.start()来创建新线程,而是让每个线程去执行一个”循环任务”,在这个”循环任务”中不停的检查是否有任务需要被执行,如果有则直接执行,也就是调用任务中的run方法,将run方法当成一个普通的方法执行,通过这种方式将只使用固定的线程就奖所有任务run方法串联起来.</p><h5 id="10-线程池的几个核心参数"><a href="#10-线程池的几个核心参数" class="headerlink" title="10. 线程池的几个核心参数:"></a>10. 线程池的几个核心参数:</h5><p>CorePoolSize: 核心线程数</p><p>maximunPoolSize: 最大线程数</p><p>keepAliveTime: 空闲线程保留时间</p><p>TimeUint: 时间单位</p><p>ThreadFactory: 线程工厂</p><p>RejectExecutionHandler: 拒绝策略</p><p>BlockingQueue: 阻塞队列</p>]]></content>
    
    
    <categories>
      
      <category>⌨Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thread</tag>
      
      <tag>ThreadPool</tag>
      
      <tag>线程池</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(⌨Java) 设计模式</title>
    <link href="/2024/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="单例模式Singleton"><a href="#单例模式Singleton" class="headerlink" title="单例模式Singleton"></a>单例模式Singleton</h3><blockquote><p>这种类型设计模式属于创建型模式,塌提供了一种创建对象的最佳方式.这种模式设计到一个单一的类,该类负责创建自己的对象,同事确保只有单个对象被创建.这个类提供了一种访问其唯一的对象的方式,可以直接访问,不需要实例化该类的对象.</p></blockquote><ul><li>懒汉式<ul><li>双重检验</li><li>静态内部类</li><li>枚举</li></ul></li><li>饿汉式</li></ul><h3 id="工厂模式Factory"><a href="#工厂模式Factory" class="headerlink" title="工厂模式Factory"></a>工厂模式Factory</h3><blockquote><p>在工厂模式中,我们在创建对象时不会对客户端暴露创建逻辑,并且是通过使用一个共同的接口来指向新创建的对象</p></blockquote><ul><li>简单工厂</li><li>静态工厂</li><li>spring ioc</li></ul><h3 id="抽象工厂模式-AbstractFactory"><a href="#抽象工厂模式-AbstractFactory" class="headerlink" title="抽象工厂模式 AbstractFactory"></a>抽象工厂模式 AbstractFactory</h3><blockquote><p>抽象工厂模式是围绕一个超级工厂创建其他工厂.该超级工厂又称为其他工厂的工厂.这种类型的设计模式属于创建型模式,它提供了一种创建对象的最佳方式.</p><p>在抽象工厂模式中,接口是负责创建一个相关对象的工厂,不需要显式指定他们的类.每个生成的工厂都能按照工厂模式提供对象.</p></blockquote><h3 id="策略模式strategy"><a href="#策略模式strategy" class="headerlink" title="策略模式strategy"></a>策略模式strategy</h3><blockquote><p>在策略模式中,我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象.策略对象改变centext对象的执行算法.</p></blockquote><h3 id="装饰者模式Decorator"><a href="#装饰者模式Decorator" class="headerlink" title="装饰者模式Decorator"></a>装饰者模式Decorator</h3><blockquote><p>这种模式创建了一个装饰类,用来包装原有的类,并在保持类方法签名完整性的前提下,提供了额外的功能.</p></blockquote><h3 id="观察者模式Observer"><a href="#观察者模式Observer" class="headerlink" title="观察者模式Observer"></a>观察者模式Observer</h3><blockquote><p>当对象间存在一对多的关系时,则使用观察者模式.比如,当一个对象被修改时,则会自动通知依赖它的对象.观察者模式属于行为型模式.</p></blockquote><h3 id="代理模式proxy"><a href="#代理模式proxy" class="headerlink" title="代理模式proxy"></a>代理模式proxy</h3><blockquote><p>在代理模式中,一个类代表另一个类的功能.这种类型的设计模式属于结构型模式.</p><p>在代理模式中,我们创建具有现有对象的对象,以便向外接提供功能接口.</p></blockquote><h3 id="责任链模式ChainResponsibility"><a href="#责任链模式ChainResponsibility" class="headerlink" title="责任链模式ChainResponsibility"></a>责任链模式ChainResponsibility</h3><blockquote><p>在这种模式中,通常每个接受者都包含对另一个接收者的引用.如果一个对象不能处理该请求,那么它会把相同的请求传给下一个接收者,以此类推.</p></blockquote><ul><li>servlet中的filter</li></ul><h3 id="组合模式Composite"><a href="#组合模式Composite" class="headerlink" title="组合模式Composite"></a>组合模式Composite</h3><blockquote><p>组合模式,又叫部分整体模式.是用于把一组相似的对象当做一个单一的对象.组合模式依据树形结构来组合对象,用来表示部分以及整体层次.这种类型的设计模式属于结构型模式,它创建了对象组的树形结构.</p></blockquote><ul><li>树结构</li></ul><h3 id="享元模式Flyweight"><a href="#享元模式Flyweight" class="headerlink" title="享元模式Flyweight"></a>享元模式Flyweight</h3><blockquote><p>主要用于减少创建对象的数量,以减少内存占用和提高性能.这种类型的设计模式属于结构型模式,它提供了减少对象数量从而改善应用所需的对象结构的方式.</p><p>享元模式尝试重用现有的同类对象,如果未找到匹配的对象,则创建新对象.</p></blockquote><h3 id="门面模式-外观模式-Facate"><a href="#门面模式-外观模式-Facate" class="headerlink" title="门面模式(外观模式)Facate"></a>门面模式(外观模式)Facate</h3><blockquote><p>外观模式隐藏系统的复杂性,并向客户端提供了一个客户端可以访问系统的接口.这种类型的设计模式属于结构型模式,它向现有的系统添加一个接口,来隐藏系统的复杂性.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>⌨Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(📒Note) 解决 Cannot determine embedded database driver class for database type NONE</title>
    <link href="/2024/07/05/%E8%A7%A3%E5%86%B3-Cannot-determine-embedded-database-driver-class-for-database-type-NONE/"/>
    <url>/2024/07/05/%E8%A7%A3%E5%86%B3-Cannot-determine-embedded-database-driver-class-for-database-type-NONE/</url>
    
    <content type="html"><![CDATA[<h4 id="网络上的解决办法-查到过3种"><a href="#网络上的解决办法-查到过3种" class="headerlink" title="网络上的解决办法 查到过3种:"></a>网络上的解决办法 查到过3种:</h4><ul><li>增加SpringBootApplication exclude</li><li>排除依赖</li><li>增加依赖h2database</li></ul><p>但是我的问题其实非常简单,但是在出现问题的时候非常容易忽略,那就是:</p><p>启动类的位置放到了不合适的子目录下</p><p>所以不论如何增加exclude,修改依赖,都会有问题存在,而且越改越迷糊,因为在这个问题存在的情况下,你修改了的exclude或者增删依赖,还会出现另外别的问题,把原本问题越带越偏.</p><p>所有.在创建一个新项目并尝试运行时.一定要确保项目结构的正确.以此为前提才能够参考其他的解决办法.</p>]]></content>
    
    
    <categories>
      
      <category>📒Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(⌨Java) 线程池</title>
    <link href="/2024/07/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/07/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h4 id="创建线程池的几种方式"><a href="#创建线程池的几种方式" class="headerlink" title="创建线程池的几种方式"></a>创建线程池的几种方式</h4><p>1.jdk自带的几种线程池方案:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService1</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService2</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService3</span> <span class="hljs-operator">=</span> Executors.newWorkStealingPool();<br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService1</span> <span class="hljs-operator">=</span> Executors.newSingleThreadScheduledExecutor();<br></code></pre></td></tr></table></figure><p>2.手动创建线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>        <span class="hljs-number">5</span>, <span class="hljs-comment">//核心线程数</span><br>        <span class="hljs-number">5</span>, <span class="hljs-comment">//最大线程数</span><br>        <span class="hljs-number">60L</span>, <span class="hljs-comment">//线程空闲存活时间</span><br>        TimeUnit.SECONDS, <span class="hljs-comment">//线程空闲存活时间单位</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>), <span class="hljs-comment">//阻塞队列</span><br>        myThreadFactory, <span class="hljs-comment">//线程工厂</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()); <span class="hljs-comment">//拒绝策略</span><br></code></pre></td></tr></table></figure><h4 id="线程池的7个核心参数"><a href="#线程池的7个核心参数" class="headerlink" title="线程池的7个核心参数"></a>线程池的7个核心参数</h4><ul><li>CorePoolSize 核心线程数</li><li>MaximumPoolSize 最大线程数</li><li>BlockingQueue 阻塞队列</li><li>KeepAliveTime 空闲线程存活时间</li><li>TimeUnit 时间单位</li><li>ThreadFactory 线程工厂</li><li>RejectedExecutionHandler 拒绝策略</li></ul><h5 id="corePoolSize-核心线程数"><a href="#corePoolSize-核心线程数" class="headerlink" title="corePoolSize 核心线程数"></a>corePoolSize 核心线程数</h5><p>核心线程数表示线程正常执行任务时的线程个数.</p><h5 id="maximumPoolSize-最大线程数"><a href="#maximumPoolSize-最大线程数" class="headerlink" title="maximumPoolSize 最大线程数"></a>maximumPoolSize 最大线程数</h5><p>如果核心线程数都在执行任务,并且阻塞队列已满,此时会允许创建小于最大线程个数的线程去执行任务.</p><h5 id="blockingQueue-阻塞队列"><a href="#blockingQueue-阻塞队列" class="headerlink" title="blockingQueue 阻塞队列"></a>blockingQueue 阻塞队列</h5><p>核心线程都在执行任务,额外的任务将会保存在阻塞队列中等待执行.</p><p>阻塞队列提供了几个实现类:</p><p>ArrayBlockingQueue 数组阻塞队列: 数组结构,有界队列</p><p>LinkedBlockingQueue 链表阻塞队列: 链表结构,无界队列</p><p>SynchronousQueue 直接切换队列: 不持有任务,如果有任务需要进入队列, 则会试图去开启一个线程立即运行,否则拒绝任务</p><h5 id="keepAliveTime-空闲线程保留时间"><a href="#keepAliveTime-空闲线程保留时间" class="headerlink" title="keepAliveTime 空闲线程保留时间"></a>keepAliveTime 空闲线程保留时间</h5><p>线程执行任务时被创建,当执行完任务时处于空闲,避免多余资源消耗而规定线程的保留时间.</p><h5 id="timeUnit-线程保留时间单位"><a href="#timeUnit-线程保留时间单位" class="headerlink" title="timeUnit 线程保留时间单位"></a>timeUnit 线程保留时间单位</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">TimeUnit.DAYS; <span class="hljs-comment">//日</span><br>TimeUnit.HOURS; <span class="hljs-comment">//小时</span><br>TimeUnit.MINUTES; <span class="hljs-comment">//分</span><br>TimeUnit.SECONDS; <span class="hljs-comment">//秒</span><br>TimeUnit.MILLISECONDS; <span class="hljs-comment">//毫秒</span><br>TimeUnit.MICROSECONDS; <span class="hljs-comment">//微妙</span><br>TimeUnit.NANOSECONDS; <span class="hljs-comment">//纳秒</span><br></code></pre></td></tr></table></figure><h5 id="threadFactory-线程工厂"><a href="#threadFactory-线程工厂" class="headerlink" title="threadFactory 线程工厂"></a>threadFactory 线程工厂</h5><p>用于创建线程,自定义时需要实现接口<code>ThreadFactory</code>接口并重写方法<code>newThread</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">namePreifx</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;threadPool-currentThreadNum-&quot;</span>;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ThreadName</span> <span class="hljs-operator">=</span> namePreifx + threadNum.getAndIncrement();<br>        <span class="hljs-type">CustomThreadGroup</span> <span class="hljs-variable">customThreadGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomThreadGroup</span>(<span class="hljs-string">&quot;custom_group&quot;</span>);<br>        <span class="hljs-comment">//非守护线程</span><br>        customThreadGroup.setDaemon(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//优先级最大</span><br>        customThreadGroup.setMaxPriority(Thread.MAX_PRIORITY);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,ThreadName);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomThreadGroup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadGroup</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomThreadGroup</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>        Log.debug(<span class="hljs-string">&quot;thread : &quot;</span> + t.getName() + e.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ThreadFactory的作用就是提供创建线程的功能和线程工厂</li><li>它是通过newThread()来创建线程,方法接收的任务是Runnable对象</li><li>它默认创建的线程都是”非守护线程”而且线程优先级都是Thread.NORM_PRIORITY</li></ul><h5 id="rejectedExecutionHandler-拒绝策略"><a href="#rejectedExecutionHandler-拒绝策略" class="headerlink" title="rejectedExecutionHandler 拒绝策略"></a>rejectedExecutionHandler 拒绝策略</h5><p><code>rejectedExecutionHandler</code>是一个接口,实现接口并重写方法<code>rejectedExecution</code>用于处理线程池拒绝策略</p><h4 id="JDK四种拒绝策略实现"><a href="#JDK四种拒绝策略实现" class="headerlink" title="JDK四种拒绝策略实现"></a>JDK四种拒绝策略实现</h4><p>AbortPolicy : 拒绝任务并抛出异常<code>RejectedExecutionException</code></p><p>DiscardPolicy : 静默拒绝,不抛出异常</p><p>DiscardOldestPolicy : 如果线程池未停止,则删除阻塞队列最前端任务(queue.poll()),并试图执行当前任务(threadPoolExecutor.excute()).</p><p>CallerRunsPolicy : 如果线程池未停止,则让调用线程自己执行任务(Runnable.run())</p><ul><li>线程池默认的拒绝策略是 AbortPolicy</li></ul>]]></content>
    
    
    <categories>
      
      <category>⌨Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thread</tag>
      
      <tag>ThreadPool</tag>
      
      <tag>线程池</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(⌨Java) 面向对象的6个基本原则</title>
    <link href="/2024/07/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%846%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <url>/2024/07/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%846%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象6个基本原则"><a href="#面向对象6个基本原则" class="headerlink" title="面向对象6个基本原则"></a>面向对象6个基本原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>引起一个类产生变化的原因只能是单一的</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>有父类的地方,子类就可以使用</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><ul><li>模块之间的依赖是通过抽象类或接口的依赖产生的</li><li>抽象类或接口不依赖具体的实现类</li><li>实现类依赖接口或抽象类</li></ul><p>所以为了降低实现类的耦合以及模块之间的松散度,要遵循几个原则:</p><ul><li>每个类尽量都有接口或抽象类,或有抽象类和接口</li><li>变量的表面类型尽量是接口或者抽象类</li><li>任何类都不应该从具体类派生</li><li>尽量不要覆写基类的方法</li><li>结合里氏替换原则使用,(有父类的地方,子类就可以使用)</li></ul><p>正置和倒置:</p><ul><li>正置就是当需要产生依赖的时候,就直接依赖到具体的实现类</li><li>而倒置则是当需要产生依赖的时候,去依赖实现类的接口或抽象类,从而降低开发中变更引起的修改风险,同时降低模块和功能的耦合.</li></ul><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>强调接口的业务需要保持单一,接口对外暴露的方法</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>接口对外开放扩展，对内封闭修改</p><h3 id="迪米特法则（最少知识原则）"><a href="#迪米特法则（最少知识原则）" class="headerlink" title="迪米特法则（最少知识原则）"></a>迪米特法则（最少知识原则）</h3><p>一个类对于其他类知道的越少越好。就是说一个对象应当对其他对象有尽可能少的了解，只和朋友通信，不和陌生人说话。英文简写为: LOD</p>]]></content>
    
    
    <categories>
      
      <category>⌨Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(💻️Front) webpack安装</title>
    <link href="/2024/07/04/webpack%E5%AE%89%E8%A3%85/"/>
    <url>/2024/07/04/webpack%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="前言-webpack"><a href="#前言-webpack" class="headerlink" title="前言 webpack"></a>前言 webpack</h3><blockquote><p>webpack是一个面向模块化的项目打包的工具,会根据原始项目的复杂依赖,生成可在服务器运行的打包文件</p></blockquote><h3 id="1-安装webpack"><a href="#1-安装webpack" class="headerlink" title="1.安装webpack"></a>1.安装webpack</h3><ul><li><p>全局安装(webpack@{版本号}) -g</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">webpack : npm install webpack@3.6.0 -g  <br></code></pre></td></tr></table></figure></li><li><p>本地安装并指明运行时为开发时运行webpack : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install webpack@3.6.0 --save-dev<br></code></pre></td></tr></table></figure></li><li><p>执行webpack,默认使用全局的webpack来根据module生成汇总文件,执行命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">webpack ./src/main.js ./dist/bundle.js<br></code></pre></td></tr></table></figure><p>index.html中引用bundle.js既可在服务器运行项目</p></li><li><p>创建js文件 <code>webpack.config.js</code>在项目根目录,并增加配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// node中的包</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-comment">//动态获取文件路径 __dirname node上下文中的参数</span><br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">module</span>: &#123;<br>      <span class="hljs-attr">rules</span>: [<br>        &#123;<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>          <span class="hljs-attr">use</span>: [ <span class="hljs-string">&#x27;css-loader&#x27;</span> ]<br>        &#125;<br>      ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置指定main.js(导入所有模块的入口js文件)位置,输出的打包文件<code>output</code>.然后在终端中执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">webpack<br></code></pre></td></tr></table></figure><p>简化了指定入口js和输入js的位置的冗杂命令</p></li></ul><h3 id="2-在node中建立映射"><a href="#2-在node中建立映射" class="headerlink" title="2.在node中建立映射:"></a>2.在node中建立映射:</h3><ul><li><p>项目终端<code>npm init</code> 生成package.json(node项目相关配置)</p></li><li><p>项目终端<code>npm install</code> 安装依赖生成package-lock.js</p></li><li><p>在package.json中 “script”增加子键值对</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>即可在终端中输入<code>npm run build</code>命令去执行webpack.</p><p>这种方式的好处是:</p><ul><li>通过npm run {自定义命令} 来执行需要的命令</li><li>node回优先在本地(项目node_modules)中查找目标命令,便于针对指定特殊版本,例如全局版本下安装的是webpack4.x,而当前项目需要使用webpack3.6.0来打包</li></ul></li></ul><h3 id="3-webpack安装loader"><a href="#3-webpack安装loader" class="headerlink" title="3.webpack安装loader"></a>3.webpack安装loader</h3><p>因为参照2018学习视频,所以不能安装现有的高版本,所以版本必须如下对应,否则打包会报错</p><ul><li>npm install –save-dev <a href="mailto:&#99;&#x73;&#x73;&#45;&#108;&#111;&#97;&#x64;&#x65;&#x72;&#x40;&#50;&#x2e;&#x30;&#x2e;&#x32;">&#99;&#x73;&#x73;&#45;&#108;&#111;&#97;&#x64;&#x65;&#x72;&#x40;&#50;&#x2e;&#x30;&#x2e;&#x32;</a></li><li>npm install –save-dev <a href="mailto:&#x73;&#116;&#x79;&#x6c;&#x65;&#x2d;&#108;&#111;&#x61;&#x64;&#x65;&#x72;&#64;&#48;&#46;&#x32;&#x33;&#x2e;&#49;">&#x73;&#116;&#x79;&#x6c;&#x65;&#x2d;&#108;&#111;&#x61;&#x64;&#x65;&#x72;&#64;&#48;&#46;&#x32;&#x33;&#x2e;&#49;</a></li><li>npm install –save-dev <a href="mailto:&#x6c;&#x65;&#115;&#115;&#45;&#108;&#111;&#97;&#x64;&#x65;&#x72;&#64;&#x34;&#x2e;&#49;&#x2e;&#x30;">&#x6c;&#x65;&#115;&#115;&#45;&#108;&#111;&#97;&#x64;&#x65;&#x72;&#64;&#x34;&#x2e;&#49;&#x2e;&#x30;</a> <a href="mailto:&#108;&#101;&#x73;&#115;&#x40;&#51;&#x2e;&#x39;&#46;&#x30;">&#108;&#101;&#x73;&#115;&#x40;&#51;&#x2e;&#x39;&#46;&#x30;</a></li><li>npm install –save-dev <a href="mailto:&#117;&#114;&#x6c;&#x2d;&#x6c;&#x6f;&#97;&#100;&#101;&#x72;&#64;&#49;&#46;&#49;&#46;&#x32;">&#117;&#114;&#x6c;&#x2d;&#x6c;&#x6f;&#97;&#100;&#101;&#x72;&#64;&#49;&#46;&#49;&#46;&#x32;</a></li><li>npm install –save-dev <a href="mailto:&#102;&#105;&#108;&#x65;&#x2d;&#x6c;&#x6f;&#x61;&#x64;&#101;&#114;&#64;&#x33;&#46;&#x30;&#46;&#49;">&#102;&#105;&#108;&#x65;&#x2d;&#x6c;&#x6f;&#x61;&#x64;&#101;&#114;&#64;&#x33;&#46;&#x30;&#46;&#49;</a></li><li>npm install babel-loader@7 babel-core babel-preset-es2015</li></ul><h3 id="4-安装vue"><a href="#4-安装vue" class="headerlink" title="4.安装vue"></a>4.安装vue</h3><ul><li><p>npm install –save <a href="mailto:&#118;&#117;&#x65;&#64;&#x32;&#46;&#x35;&#x2e;&#x32;&#49;">&#118;&#117;&#x65;&#64;&#x32;&#46;&#x35;&#x2e;&#x32;&#49;</a></p><p>安装后在<code>webpack.config.js</code>中增加配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>:&#123;...&#125;,<br><span class="hljs-attr">resolve</span>:&#123;<br>      <span class="hljs-attr">alias</span>: &#123;<br>        <span class="hljs-comment">// 指定vue版本</span><br>        <span class="hljs-string">&#x27;vue$&#x27;</span>:<span class="hljs-string">&#x27;vue/dist/vue.esm.js&#x27;</span><br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>并且导入时的语句为下,以保证使用<code>new Vue(&#123;&#125;)</code>正常:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue/dist/vue.common.js</span><br></code></pre></td></tr></table></figure><ul><li>使用.vue文件需要安装相应loader:</li><li>npm install –save-dev <a href="mailto:&#118;&#117;&#101;&#x2d;&#108;&#111;&#x61;&#100;&#101;&#x72;&#64;&#49;&#53;&#x2e;&#x34;&#x2e;&#50;">&#118;&#117;&#101;&#x2d;&#108;&#111;&#x61;&#100;&#101;&#x72;&#64;&#49;&#53;&#x2e;&#x34;&#x2e;&#50;</a> <a href="mailto:&#118;&#117;&#x65;&#45;&#x74;&#x65;&#109;&#x70;&#x6c;&#x61;&#116;&#x65;&#x2d;&#99;&#111;&#109;&#x70;&#x69;&#108;&#101;&#114;&#x40;&#50;&#x2e;&#x35;&#46;&#50;&#x31;">&#118;&#117;&#x65;&#45;&#x74;&#x65;&#109;&#x70;&#x6c;&#x61;&#116;&#x65;&#x2d;&#99;&#111;&#109;&#x70;&#x69;&#108;&#101;&#114;&#x40;&#50;&#x2e;&#x35;&#46;&#50;&#x31;</a></li></ul></li></ul><h3 id="5-plugin"><a href="#5-plugin" class="headerlink" title="5.plugin"></a>5.plugin</h3><ul><li>npm install –save-dev <a href="mailto:&#x68;&#116;&#x6d;&#x6c;&#45;&#119;&#x65;&#98;&#112;&#x61;&#99;&#107;&#45;&#112;&#108;&#x75;&#x67;&#105;&#110;&#64;&#x33;&#x2e;&#x32;&#x2e;&#x30;">&#x68;&#116;&#x6d;&#x6c;&#45;&#119;&#x65;&#98;&#112;&#x61;&#99;&#107;&#45;&#112;&#108;&#x75;&#x67;&#105;&#110;&#64;&#x33;&#x2e;&#x32;&#x2e;&#x30;</a> 让dist文件夹中包含index.html</li><li>const webpack &#x3D; require(“webpack”) 引入模块 用来添加版权</li><li>代码丑化压缩,npm install <a href="mailto:&#117;&#x67;&#x6c;&#105;&#x66;&#121;&#x6a;&#115;&#x2d;&#119;&#101;&#98;&#112;&#97;&#99;&#107;&#45;&#x70;&#x6c;&#x75;&#x67;&#105;&#110;&#64;&#49;&#x2e;&#x31;&#x2e;&#x31;">&#117;&#x67;&#x6c;&#105;&#x66;&#121;&#x6a;&#115;&#x2d;&#119;&#101;&#98;&#112;&#97;&#99;&#107;&#45;&#x70;&#x6c;&#x75;&#x67;&#105;&#110;&#64;&#49;&#x2e;&#x31;&#x2e;&#x31;</a> –save-dev</li><li>node server : npm Install <a href="mailto:&#119;&#x65;&#x62;&#x70;&#97;&#99;&#x6b;&#x2d;&#x64;&#x65;&#118;&#x2d;&#115;&#101;&#114;&#118;&#101;&#x72;&#x40;&#50;&#46;&#57;&#46;&#x33;">&#119;&#x65;&#x62;&#x70;&#97;&#99;&#x6b;&#x2d;&#x64;&#x65;&#118;&#x2d;&#115;&#101;&#114;&#118;&#101;&#x72;&#x40;&#50;&#46;&#57;&#46;&#x33;</a> –save-dev</li></ul><p><code>webpack.config.js</code>中增加:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">plugins</span>:[...],<br>    <span class="hljs-attr">devServer</span>: &#123;<br>      <span class="hljs-comment">// 为哪一个文件夹提供本地服务,默认时根文件夹</span><br>      <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;./dist&#x27;</span>,<br>      <span class="hljs-comment">// 页面实时刷新</span><br>      <span class="hljs-attr">inline</span>: <span class="hljs-literal">true</span><br>      <span class="hljs-comment">// post 端口号 默认8080</span><br>      <span class="hljs-comment">// historyApiFallback 在SPA页面中,依赖HTML5的history模式</span><br>    &#125;<br></code></pre></td></tr></table></figure><p><code>package.json</code>中增加:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server&quot;</span><span class="hljs-comment">//增加 --open会让浏览器自动打开</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><ul><li>npm install webpack-merge <a href="mailto:&#x2d;&#45;&#115;&#97;&#x76;&#101;&#x2d;&#x64;&#x65;&#118;&#x40;&#52;&#46;&#49;&#x2e;&#x35;">&#x2d;&#45;&#115;&#97;&#x76;&#101;&#x2d;&#x64;&#x65;&#118;&#x40;&#52;&#46;&#49;&#x2e;&#x35;</a> 合并配置插件</li></ul>]]></content>
    
    
    <categories>
      
      <category>💻️Front</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(💻️Front) Vuex</title>
    <link href="/2024/07/04/Vuex/"/>
    <url>/2024/07/04/Vuex/</url>
    
    <content type="html"><![CDATA[<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><ul><li>vuex是一个专为Vue.js应用程序开发的状态管理模式.</li><li>状态管理模式.集中式存储管理  &#x3D;&gt; 公共对象</li></ul><h3 id="Vuex安装"><a href="#Vuex安装" class="headerlink" title="Vuex安装"></a>Vuex安装</h3><ul><li>npm install vuex –save</li></ul><h3 id="vuex中的几个核心概念"><a href="#vuex中的几个核心概念" class="headerlink" title="vuex中的几个核心概念:"></a>vuex中的几个核心概念:</h3><ul><li>state 存放状态信息<ul><li>单一状态树既单一数据源</li></ul></li><li>属性在初始化时添加到state中, 都会成为响应式的属性</li><li>mutations 修改state中,操作在组件中留痕<ul><li>提交时可以额外传递参数payload commit(“methodName”,param)</li><li>还有一种特殊的传递方式 commit({ type:”methodName” ,param:11,param2:123})</li></ul></li><li>actions 异步操作</li><li>getters 类似computed</li><li>modules</li></ul>]]></content>
    
    
    <categories>
      
      <category>💻️Front</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vuex</tag>
      
      <tag>VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(⌨Java) SpringBoot笔记</title>
    <link href="/2024/07/04/SpringBoot%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/04/SpringBoot%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="自动装配的原理"><a href="#自动装配的原理" class="headerlink" title="自动装配的原理"></a>自动装配的原理</h2><h3 id="源码原理-版本1-5-16-RELEASE"><a href="#源码原理-版本1-5-16-RELEASE" class="headerlink" title="源码原理: (版本1.5.16.RELEASE)"></a>源码原理: (版本1.5.16.RELEASE)</h3><p>1.SpringBoot项目都会在application启动类上使用注解@SpringBootApplication</p><p>2.@SpringBootApplication中包含一下注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span> <span class="hljs-comment">//springboot相关配置 spring的一个组件</span><br><span class="hljs-meta">@EnableAutoConfiguration</span> <span class="hljs-comment">//自动装配 自动导入包</span><br><span class="hljs-meta">@ComponentScan</span> <span class="hljs-comment">//扫描当前类同级的包</span><br></code></pre></td></tr></table></figure><p>3.@EnableAutoConfiguration自动装配注解中包含</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span> <span class="hljs-comment">//自动注册包</span><br><span class="hljs-meta">@Import(EnableAutoConfigurationImportSelector.class)</span><span class="hljs-comment">//自动导入包的核心 自动导入选择器</span><br></code></pre></td></tr></table></figure><ul><li><pre><code class="java">@AutoConfigurationPackage &gt; @Import(AutoConfigurationPackages.Registrar.class) //自动注册包<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>EnableAutoConfigurationImportSelector继承类AutoConfigurationImportSelector<br><br><span class="hljs-bullet">- </span>AutoConfigurationImportSelector中selecImport()方法(2.0后springboot版本在方法getAutoConfigurationEntry()中)getCandidateConfigurations来获取候选的配置<br><br><span class="hljs-bullet">- </span>getCandidateConfigurations获取的配置如下<br><br>~~~ java<br><span class="hljs-comment">//标注了EnableAutoConfiguration注解的类</span><br>protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;<br><span class="hljs-code">   return EnableAutoConfiguration.class;</span><br><span class="hljs-section">&#125;</span><br><span class="hljs-section">~~~</span><br><br><span class="hljs-bullet">- </span>getCandidateConfigurations中方法<br><br><span class="hljs-code">```java</span><br><span class="hljs-code">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="hljs-code">      getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>loadFactoryNames方法获取所有的配置</p></li><li><pre><code class="java">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) //从项目中获取ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION) //从系统中获取</code></pre></li><li><p>从这些资源中遍历了所有的nextElement)(自动配置),遍历完成之后,封装为一个Properties供我们使用</p></li><li><p>常量 FACTORIES_RESOURCE_LOCATION &gt; “META-INF&#x2F;spring.factories”</p></li><li><p>文件spring.factories在spring-boot-autoconfigure-x.x.x.RELEASE.jar的META-INF&#x2F;下</p></li><li><p>其中配置类名称就是springboot自动加载的所有配置类</p></li></ul><h4 id="为什么有的配置没有加载"><a href="#为什么有的配置没有加载" class="headerlink" title="为什么有的配置没有加载?"></a>为什么有的配置没有加载?</h4><ul><li>需要在pom中导入对应的strat才能有作用</li><li>在配置类中有注解@ConditionalOnClass,用于判断当前类是否存在,不存在则该配置无效</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h4><p> springboot所有的自动配置都是在启动时扫描并加载,但是不一定生效,要判断条件是否生效,只要导入对应的start,自动装配就会生效.</p><h3 id="几点总结"><a href="#几点总结" class="headerlink" title="几点总结:"></a>几点总结:</h3><p>1.springbook在启动的时候,从类路劲虾&#x2F;META-INF&#x2F;spring.factories获取指定的值</p><p>2.将这些自动配置的类导入容器,自动配置就会生效,帮用户进行自动配置</p><p>3.整合javaEE,解决方案和自动配置的东西都会在spring-boot-autoconfigure-2.2.0.RELEASE.jar这个包下</p><p>4.他会把所有导入的组件,以类名的方式返回,这些组件就会被添加到容器</p><p>5.容器也会存在非常多的xxxAutoConfiguration的文件(@Bean),就是这些类给容器中导入了这个场景需要的所有组件,并自动配置,@Configuration</p><p>7.有了自动配置类,就免去了手动配置的步骤.</p><h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h2><h3 id="SpringApplication主要完成下面四件事"><a href="#SpringApplication主要完成下面四件事" class="headerlink" title="SpringApplication主要完成下面四件事:"></a>SpringApplication主要完成下面四件事:</h3><p>1.推断应用的类型是普通项目还是web项目</p><p>2.查找并加载所有的可用初始化器,设置到initializers属性中</p><p>3.找出所有的应用程序监听器,设置listeners属性中</p><p>4.推断并设置main方法的定义类,找到运行的主类</p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>1.SpringBoot启动会加载大量的自动配置类</p><p>2.我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中</p><p>3.在看这个配置类中到底配置了那些组件(只要组件存在,就不需要手动配置)</p><p>4.给容器中自动配置类添加组件的时候,会从properties嘞中获取某些属性,我们只需要在配置文件中指定这些属性即可</p><p>xxxAutConfiguration: 自动配置类;给容器中添加组件</p><p>xxxProperties: 封装配置文件中相关属性</p><p>配置文件中增加 debug &#x3D; true 可以查看当前加载了哪些配置类</p><h1 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="SpringBoot Web开发"></a>SpringBoot Web开发</h1><p>1.在springboot,我们可以使用一下方式处理静态资源</p><ul><li>webjars</li><li>public, static ,resources ,&#x2F;**</li></ul><p>2.优先级 resources &gt; static(默认) &gt; public</p><h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><p>几个关键类:</p><ul><li>WebSecurityConfigurerAdapter: 自定义security策略</li><li>AuthenticationManagerBuilder: 自定义认证策略</li><li>@EnableWebSecurity: 开启WebSecurity模式</li></ul><p>Spring Security的两个主要目标是”认证”和”授权”(访问控制)</p><p>“认证”(Authentication)</p><p>“授权”(Authorization)</p><p>这个概念是通用的,而不是只在Spring Security中存在</p>]]></content>
    
    
    <categories>
      
      <category>⌨Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(📦DB) SQL语句优化</title>
    <link href="/2024/07/04/SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/"/>
    <url>/2024/07/04/SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h4 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h4><p>1.查询时避免全表扫描，所以在where和order by涉及的列上建立索引</p><p>2.避免在where子句中使用!&#x3D; , &lt;&gt;操作符 这会导致引擎放弃索引而进行全表扫描</p><p>3.避免在where子句中对字段进行null值判断,会导致全表扫描,所以在建立字段时,给一个默认值</p><p>4.使用like语句时,条件不要使用%前缀,否则导致全表扫描</p><p>5.避免在where子句中对字段进行函数操作,会导致查询分析器放弃索引.</p><p>6.避免在where子句中对字段进行表达式操作,会导致索引失效.</p><p>7.使用exists代替in,可以提高查询速度</p><ul><li>区别在于in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)</li><li>如果是exists,那么以外层表为驱动表,先被访问.</li><li>如果是in,那么先执行子查询.</li><li>所以in适合于外表大而内表小的情况;exists适合于外表小而内标大的情况.</li></ul><p>8.避免在where子句中使用is null 或者 is not null,否则会导致索引失效</p><p>9.避免在where子句中使用or作为链接条件</p><ul><li>or两边的字段中,如果有一个不是索引字段,而其他条件也不是索引字段,会造成该查询不会走索引的情况.</li><li>利用union和union all,但是union会对结果进行唯一性过滤操作,这会涉及到排序,所以会更加消耗资源,所以如果不需要进行唯一性处理的话,尽量使用union all</li></ul><p>10.in和not in慎用, 否则会导致全表扫描,能用between就不要用in</p><p>11.避免隐式类型转换,会导致索引失效</p><p>12.不要使用select * from t</p><ul><li>select * 增加了资源消耗</li><li>增加了使用覆盖索引的可能性</li></ul><p>13.如果排序上没有用到索引,就尽量少排序,</p><p>14.在使用索引字段作为条件时,如果该索引是复合索引,那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引,否则该索引将不会被使用,并且经可能的让字段顺序与索引顺序相一致.</p>]]></content>
    
    
    <categories>
      
      <category>🗃DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(⌨Java) Spring加载bean的过程</title>
    <link href="/2024/07/04/Spring%E5%8A%A0%E8%BD%BDbean%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/07/04/Spring%E5%8A%A0%E8%BD%BDbean%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="spring加载bean的过程"><a href="#spring加载bean的过程" class="headerlink" title="spring加载bean的过程"></a>spring加载bean的过程</h3><p>加载xml &gt; 解析xml &gt; 封装BeanDefinition &gt; 实例化 &gt; 放在容器中 &gt; 从容器中获取</p><p>容器:用来存放bean &gt; Map结构存储 &gt; 存储形式 &gt; 三级缓存</p><ul><li>存数形式猜想</li></ul><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">k:</span>Stirng v:<span class="hljs-type">Object</span><br><span class="hljs-symbol">k:</span><span class="hljs-keyword">Class</span> v:<span class="hljs-type">Object</span><br><span class="hljs-symbol">k:</span><span class="hljs-type">String</span> v:ObjectFactory<br><span class="hljs-symbol">k:</span><span class="hljs-type">String</span> v:BeanDifinition<br></code></pre></td></tr></table></figure><p>bean的配置文件解析接口</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">BeanDefinitionReader</span><br></code></pre></td></tr></table></figure><p>提供的实现用来解析不同类型的配置文件所配置的bean</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">BeanFactory <span class="hljs-comment">//整个容器的根接口,也是容器的入口</span><br></code></pre></td></tr></table></figure><p>常用类: DefaultListableBeanFactory,AbstractAutowireCapableBeanFactory</p><p>后置处理器(增强器) PostProcessor </p><p>两个实现类:</p><ul><li><p>BeanFactoryPostProcessor(修改BeanDefinition信息)</p></li><li><p>BeanPostProcessor(增强Bean信息)</p></li></ul><p>实例化: 在堆中开辟一块空间,但是对象的属性值都是默认值</p><p>初始化: 给属性设置值,源码中两个步骤.填充属性&gt;执行初始化方法(init-method)</p>]]></content>
    
    
    <categories>
      
      <category>⌨Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(⌨Java) Spring启动过程中的refresh方法</title>
    <link href="/2024/07/04/Spring%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84refresh%E6%96%B9%E6%B3%95/"/>
    <url>/2024/07/04/Spring%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84refresh%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring启动中的refresh方法"><a href="#Spring启动中的refresh方法" class="headerlink" title="Spring启动中的refresh方法"></a>Spring启动中的refresh方法</h2><blockquote><p>refresh方法中包含的13个关键的方法,一行重要代码</p></blockquote><h3 id="1-prepareRefresh"><a href="#1-prepareRefresh" class="headerlink" title="1.prepareRefresh()"></a>1.prepareRefresh()</h3><p>​负责容器刷新的准备工作</p><p>​1.设置容器的启动时间</p><p>​2.设置活跃状态为true</p><p>​3.设置关闭状态为false</p><p>​4.获取Environment对象,并加载当前系统的属性值到Environment对象中</p><p>​5.准备监听器和事件的集合对象,默认为空的集合</p><h3 id="2-configurableListableBeanFactory-beanFactory-obtainFreshBeanFactory"><a href="#2-configurableListableBeanFactory-beanFactory-obtainFreshBeanFactory" class="headerlink" title="2.configurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();"></a>2.configurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</h3><p>​1.创建容器对象DefaultListableBeanFactory</p><p>​2.加载xml配置文件的属性值到当前工厂,最重要是BeanDefinition</p><h3 id="3-prepareBeanFactory-beanFactory"><a href="#3-prepareBeanFactory-beanFactory" class="headerlink" title="3.prepareBeanFactory(beanFactory)"></a>3.prepareBeanFactory(beanFactory)</h3><p>​为了完成bean工厂的一些初始化操作,初始化bean工厂,设置工厂的一些属性值</p><h3 id="4-postProcessBeanFactory-beanFactory"><a href="#4-postProcessBeanFactory-beanFactory" class="headerlink" title="4.postProcessBeanFactory(beanFactory)"></a>4.postProcessBeanFactory(beanFactory)</h3><p>BeanFactoryPostProcess接口中也有同名方法</p><p>方法体为空,模板方法.便于后继自定义处理</p><h3 id="5-invokeBeanFactoryPostProcess-beanFactory"><a href="#5-invokeBeanFactoryPostProcess-beanFactory" class="headerlink" title="5.invokeBeanFactoryPostProcess(beanFactory)"></a>5.invokeBeanFactoryPostProcess(beanFactory)</h3><p>开始执行一些BFPP</p><h3 id="6-registerBeanPostProcessors-beanFactory"><a href="#6-registerBeanPostProcessors-beanFactory" class="headerlink" title="6.registerBeanPostProcessors(beanFactory)"></a>6.registerBeanPostProcessors(beanFactory)</h3><p>注册BeanPostProcess</p><h3 id="7-initMessageSource"><a href="#7-initMessageSource" class="headerlink" title="7.initMessageSource()"></a>7.initMessageSource()</h3><p>处理国际化相关的内容</p><h3 id="8-invokeApplicationEventMulticaster"><a href="#8-invokeApplicationEventMulticaster" class="headerlink" title="8.invokeApplicationEventMulticaster()"></a>8.invokeApplicationEventMulticaster()</h3><p>初始化广播器</p><h3 id="9-onRefresh"><a href="#9-onRefresh" class="headerlink" title="9.onRefresh()"></a>9.onRefresh()</h3><p>一个模板方法,可以定义要使用的web容器</p><p>springboot中默认是使用内嵌tomcat作为容器</p><h3 id="10-registerListeners"><a href="#10-registerListeners" class="headerlink" title="10.registerListeners()"></a>10.registerListeners()</h3><p>注册监听器</p><h3 id="11-finishBeanFactoryInitialization-beanFactory"><a href="#11-finishBeanFactoryInitialization-beanFactory" class="headerlink" title="11.finishBeanFactoryInitialization(beanFactory)"></a>11.finishBeanFactoryInitialization(beanFactory)</h3><p>实例化非抽象的,单例的,非懒加载的bean</p><h3 id="12-finishRefresh"><a href="#12-finishRefresh" class="headerlink" title="12.finishRefresh()"></a>12.finishRefresh()</h3><h3 id="13-destroyBeans"><a href="#13-destroyBeans" class="headerlink" title="13.destroyBeans()"></a>13.destroyBeans()</h3><h3 id="14-cancelRefresh-ex"><a href="#14-cancelRefresh-ex" class="headerlink" title="14.cancelRefresh(ex)"></a>14.cancelRefresh(ex)</h3>]]></content>
    
    
    <categories>
      
      <category>⌨Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(📦DB) Redis缓存策略</title>
    <link href="/2024/07/04/Redis%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <url>/2024/07/04/Redis%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="Redis缓存策略"><a href="#Redis缓存策略" class="headerlink" title="Redis缓存策略"></a>Redis缓存策略</h3><p>LRU 最近最少使用，根据使用记录来判断，最近如果被使用，则未来被使用的几率更高</p><p>LFU 一直一来最少被使用，通过hit属性，hit值最小的会被清理</p><h3 id="几种具体配置："><a href="#几种具体配置：" class="headerlink" title="几种具体配置："></a>几种具体配置：</h3><p>allkeys-lru 所有keys中，优先删除最近最少被使用的键</p><p>allkeys-random 所有key中，随机删除一部分key</p><p>volatile-lru 设置了expire的key中，优先删除最近最少被使用的key</p><p>volatile-random 设置了expire的key中，随机删除一部分key</p><p>volatile-ttl 设置了expire的key中，删除部分剩余时间短的key</p><p>noeviction 不删除key，在内存满了之后，会报错</p>]]></content>
    
    
    <categories>
      
      <category>📦DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(📦DB) Redis笔记</title>
    <link href="/2024/07/04/Redis%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/04/Redis%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p>.&#x2F;redis-server ..&#x2F;redis.conf</p><p>.&#x2F;redis-cli -p 6379</p><h2 id="redis性能测试"><a href="#redis性能测试" class="headerlink" title="redis性能测试"></a>redis性能测试</h2><p>.&#x2F;redis-benchmark -h localhost -p 6379 -c 100 -n 100000</p><h2 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h2><h3 id="redis-key"><a href="#redis-key" class="headerlink" title="redis-key"></a>redis-key</h3><ul><li>连接数据库 &#x2F;redis-cli -p 6379</li><li>切换数据库 select 0</li><li>数据库大小 dbsize</li><li>清空数据库 flushdb</li><li>清空所有数据库 flushall</li><li>判断key是否存在: exist name</li><li>移除当前的key: move name</li><li>设置key 的过期时间(单位为s): expise name 10</li><li>查看当前key的剩余时间: ttl name</li><li>查看当前key类型: type name</li></ul><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串):"></a>String(字符串):</h3><ul><li>追加字符串: append name “aaa”  如果这个key不存在,就相当于set key</li><li>获取长度: strlen name</li><li>加一减一: incr name &#x2F; decr name</li><li>按步长加减: incrby name 10 &#x2F; decrby name 10</li><li>截取字符串 : getrange name 4 5 &#x2F;getrange name 0 -1(获取全部字符串)</li><li>替换: setrange name 4 abc</li><li>设置过期时间: setex name 30 hello</li><li>不存在时创建: setnx name value (在分布式锁中常用)</li><li>批量设置键值对: mset k1 a k2 b k3 c</li><li>批量获取键值对: mget k1 k2 k3</li><li>批量设置不存在键值对: msetnx k1 a k2 b k3 c 原子性操作,要么一起成功,要么一起失败</li><li>先get再set: getset 获取原来的值并设置新的值</li></ul><h3 id="List-链表"><a href="#List-链表" class="headerlink" title="List(链表)"></a>List(链表)</h3><p><code>list命令大多是在命令前增加一个L</code></p><ul><li>集合左添加(第一位)元素: lpush list a</li><li>集合右添加(最后一位)元素: rpush list b</li><li>返回集合内容: lrange list 0 -1</li><li>移除第一个元素: lpop </li><li>移除最后一个元素: rpop</li><li>通过下标获取值: lindex list 0</li><li>获取长度: llen</li><li>移除指定的值: lrem list 1 a</li><li>通过下标截取指定长度: ltrim list 0 1</li><li>移除列表的最后一个元素,并添加到新的列表中 : rpoplpush list1 list2</li><li>将列表中指定下标的值替换成另外一个值(相当于更新): lset list o aaa<ul><li>如果不存在列表,就会报错,如果存在则更新值</li></ul></li><li>将某个具体的value插入到列表中某个元素的前面或后面: linsert list before&#x2F;after aaa bbb</li></ul><h3 id="set-无序集合"><a href="#set-无序集合" class="headerlink" title="set(无序集合)"></a>set(无序集合)</h3><ul><li>set里面添加值: sadd name value</li><li>查看set中的元素: smebers name</li><li>判断某个值在不在set中: sismebers name value</li><li>获取set集合中的元素个数: scard set</li><li>移除指定元素: srem set value</li><li>随机抽出指定个数的元素: srandmember name count</li><li>随机移除指定个数的元素: spop set count</li><li>将一个指定的值,移到另外一个set中: smove myset myset2 “value”</li><li>差集: sdiff set1 set2</li><li>交集: sinter set1 set2</li><li>并集: sunion set1 set2</li></ul><h3 id="hash-map集合"><a href="#hash-map集合" class="headerlink" title="hash(map集合)"></a>hash(map集合)</h3><ul><li>set一个值: hset map key value</li><li>get一个值: hget map key</li><li>get所有值: hgetall map</li><li>设置多个值: hmset map key1 value1 key2 value2</li><li>获取多个值: hmget map key1 key2</li><li>删除指定键值对: hdel map key</li><li>获取长度: hlen map</li><li>判断指定的key是否存在: hexists map key</li><li>只获取所有key: hkeys map</li><li>只获取所有value: hvals map</li><li>让某一个值增长指定值: hincrby map key1 1</li><li>如果不存在则可以设置,如果存在则不能设置: hsetnx map key value</li></ul><h3 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset(有序集合)"></a>zset(有序集合)</h3><ul><li>添加元素 : zadd myset 1 one</li><li>添加多个元素: zadd myset 2 two 3 three</li><li>遍历: zrange myset 0 -1</li><li>排序(升序): ZRANGEBYSCORE myset -inf +inf withscores</li><li>删除元素: zrem myset value</li><li>反转遍历: ZREVRANGE myset 0 -1</li></ul><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h3><ul><li>添加坐标:  geoadd china:city 121.48169 31.235435 shanghai<ul><li>南北极不能直接添加</li></ul></li><li>获取某个地点的经纬度: geopos china:city wuhan</li><li>获取两点之间距离: geodist china:city shanghai beijing km [命令] [key] [value1] [value2] [unit(单位)]</li><li>以某点的经纬度为中心,获取指定半径内的元素: GEORADIUS china:city 110 30 500 km<ul><li>GEORADIUS china:city 110 30 500 km withdist 显示到中心点的距离</li><li>GEORADIUS china:city 110 30 500 km withcoord 显示满足条件的定位信息</li><li>GEORADIUS china:city 110 30 500 km count 2 筛选出满足条件的个数</li><li>GEORADIUS china:city 110 30 500 km withdist withcoord count 1</li></ul></li><li>以某个元素为中心,获取指定半径内的元素: GEORADIUSBYMEMBER china:city beijing 1000 km</li><li>将经纬度转变成11个字符的geohash字符串: geohash china:city beijing</li></ul><blockquote><p>geo底层是zset实现,所以删除元素和遍历可以使用zrem命令和zrange命令</p></blockquote><h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><blockquote><p>什么是基数? –不重复的元素</p><blockquote><p>Hyperloglog作用: 去除两个集合的重复</p><p>Hyperloglog使用场景: 网站UV</p></blockquote></blockquote><ul><li>创建一组元素: pfadd mykey a b c d e f g h</li><li>统计元素个数: pfcount mykey</li><li>合并两组,并去除重复(并集): PFMERGE mykey3 mykey mykey2</li></ul><p>如果允许容错,可以使用.</p><p>如果不允许容错,则使用set.</p><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><blockquote><p>位存储</p><blockquote><p>作用: 通过0和1来表示</p></blockquote><blockquote><p>使用场景: 例如统计用户信息,用户是否活跃;是否已打卡;是否登录</p></blockquote></blockquote><p>使用bitmap来记录周一到周日的打卡记录:</p><p>127.0.0.1:6379&gt; setbit sign 0 1 &#x2F;&#x2F;设置一个bitmap值<br>(integer) 0<br>127.0.0.1:6379&gt; setbit sign 1 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit sign 2 0<br>(integer) 0<br>127.0.0.1:6379&gt; setbit sign 3 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit sign 4 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit sign 5 1<br>(integer) 0<br>127.0.0.1:6379&gt; setbit sign 6 0</p><ul><li><p>设置一个bitmaps值: setbit sign 0 1</p></li><li><p>获取某一个bitmap的值: getbit sign 1</p></li><li><p>统计总数: bitcount sign</p></li></ul><h2 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><p>redis事务本质: 一组命令的集合,一个事务中的所有命令都会被序列化,再事务执行过程中,会按照顺序执行.</p><blockquote><p>—— 队列 set set set 执行 ——</p></blockquote><p>&#x3D;&#x3D;redis 事务没有隔离级别的概念&#x3D;&#x3D;</p><p>所有的命令在事务中,并没有直接被执行,只是发起执行命令的时候才会执行</p><p>&#x3D;&#x3D;redis单条命令是保持原子性的,但是事务不保证原子性&#x3D;&#x3D;</p><p>redis的事务:</p><ul><li>开启事务(multi)</li><li>命令入队(…)</li><li>执行事务(exec)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; MULTI #开启事务<br>OK<br>127.0.0.1:6379&gt; set k1 v1 #入队命令<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; keys *<br>QUEUED<br>127.0.0.1:6379&gt; exec #执行事务<br>1) OK<br>2) OK<br>3) OK<br>4) 1) &quot;k2&quot;<br>   2) &quot;k1&quot;<br>   3) &quot;k3&quot;<br></code></pre></td></tr></table></figure><ul><li>放弃事务(discard)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; MULTI<br>OK<br>127.0.0.1:6379&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; set k4 v4<br>QUEUED<br>127.0.0.1:6379&gt; DISCARD #放弃事务<br>OK<br>127.0.0.1:6379&gt; get k4<br>(nil)<br></code></pre></td></tr></table></figure><hr><blockquote><p>编译时异常(代码问题)事务中所有命令都不会执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; MULTI<br>OK<br>127.0.0.1:6379&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 qweqwe<br>QUEUED<br>127.0.0.1:6379&gt; getset k2 #命令有错<br>(error) ERR wrong number of arguments for &#x27;getset&#x27; command<br>127.0.0.1:6379&gt; exec<br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; get k2<br>&quot;v2&quot;<br></code></pre></td></tr></table></figure><hr><blockquote><p>运行时异常,如果事务列表中存在语法异常,那么执行命令时,命令会正常运行,错误命令抛出异常</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; MULTI<br>OK<br>127.0.0.1:6379&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; incr k1<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>1) OK<br>2) (error) ERR value is not an integer or out of range #显示运行错误<br>127.0.0.1:6379&gt; get k1 #其他命令正常执行<br>&quot;v1&quot;<br></code></pre></td></tr></table></figure><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁 :"></a>悲观锁 :</h4><ul><li>很悲观,认为什么时候都会出问题,无论做什么都会上锁</li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁:"></a>乐观锁:</h4><ul><li>很乐观,认为什么时候都不会出问题,所以不会上锁,更新数据的时候去判断一下,在此期间是否有人修改过数据.</li></ul><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁:"></a>加锁:</h4><p>多线程修改值时,使用watch key 命令来给key加锁</p><p>如果需要修改 ,就是用unwatch解锁 然后再加锁执行</p><h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><hr><p>SpringBoot2.x之后,原来使用的jedis被替换为lettuce,采用netty,视力可以在多个线程中进行共享,不存在现成不安全的情况,可以减少线程数据.更像nio模式</p><p>jedis:采用直连,多个现成操作的话,会有线程安全问题,为避免线程不安全,使用jedis pool连接池 更像bio模式</p><p>springboot所有的配置类,都有一个自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><span class="hljs-comment">//我们可以自定义一个redisTemplate来替换这个默认的</span><br><span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>  <span class="hljs-comment">//默认的 redisTemplate没有过多的配置,redis对象都是需要序列化的!</span><br>  <span class="hljs-comment">//两个泛型都是object,object的类型,我们后使用需要墙纸转换&lt;String,Object&gt;</span><br>   RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>   template.setConnectionFactory(redisConnectionFactory);<br>   <span class="hljs-keyword">return</span> template;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title function_">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>   <span class="hljs-type">StringRedisTemplate</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisTemplate</span>();<br>   template.setConnectionFactory(redisConnectionFactory);<br>   <span class="hljs-keyword">return</span> template;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>整合</p></blockquote><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-配置连接"><a href="#2-配置连接" class="headerlink" title="2.配置连接"></a>2.配置连接</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Springboot所有的配置类,都有一个自动配置类 配置类可以在源码中找到 源码spring-boot-autoconfigure的配置文件中</span><br><span class="hljs-comment"># 自动配置嘞都会绑定一个properties配置文件  RedisAutoConfiguration</span><br><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">127.0.0.1</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br></code></pre></td></tr></table></figure><h4 id="3-自定义redisTemplate"><a href="#3-自定义redisTemplate" class="headerlink" title="3.自定义redisTemplate"></a>3.自定义redisTemplate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.noah.config;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> RedisConfig</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> noah</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 4/8/21 3:25 PM</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Author</span> yz</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span> 自定义的redisTemplate 序列化问题</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 4/8/21 3:46 PM</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisConnectionFactory</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> org.springframework.data.redis.core.RedisTemplate&lt;java.lang.String,java.lang.Object&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br><br>        <span class="hljs-comment">//序列化配置</span><br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);<br>        <span class="hljs-comment">//String 的序列化</span><br>        <span class="hljs-type">StringRedisSerializer</span> <span class="hljs-variable">stringRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br><br>        <span class="hljs-comment">//key采用String的序列化方式</span><br>        template.setKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">//hash的key采用String的序列化方式</span><br>        template.setHashKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">//value采用String的序列化方式</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">//hash的value采用String的序列化方式</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        template.afterPropertiesSet();<br><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="redis-conf详解"><a href="#redis-conf详解" class="headerlink" title="redis.conf详解"></a>redis.conf详解</h2><p>启动的时候,就通过配置文件来启动</p><blockquote><p>单位</p></blockquote><p><img src="/image/postImage/image-20210408163752409.png"></p><p>1.配置文件 unit单位 对大小写不敏感</p><blockquote><p>包含</p></blockquote><p><img src="/image/postImage/image-20210408163834760.png"></p><p>可以把配置文件都包含过来</p><blockquote><p>网络</p></blockquote><p><img src="/image/postImage/image-20210408163928740.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">bind 172.0.0.1 #绑定的ip<br>protected-mode yes #保护模式<br>port 6379 #端口<br></code></pre></td></tr></table></figure><blockquote><p>通用GENERAL</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">daemonize yes #以守护进程的方式运行,默认是no,我们需要自己开启为yes<br>pidfile /var/run/redis_6379.pid #如果以后台的方式运行,我们就需要指定一个pid文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">日志</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Specify the server verbosity level.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This can be one of:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">debug (a lot of information, useful <span class="hljs-keyword">for</span> development/testing)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">notice (moderately verbose, what you want <span class="hljs-keyword">in</span> production probably)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">warning (only very important / critical messages are logged)</span><br>loglevel notice<br><br>logfile &quot;&quot; #日志的文件位置名<br>database 16 #数据库的数量,默认是16个数据库<br><br></code></pre></td></tr></table></figure><blockquote><p>快照</p></blockquote><p>持久化,再规定的时间内,执行了多少次操作,则会持久化到文件 .rdb .aof</p><p>redis是内存数据库如果没有持久化,那么断电数据即失去.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">如果900s内,如果至少有一个1 key进行了修改,我们就进行持久化操作</span><br>save 900 1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果300s内,如果至少有10次key进行了修改,就进行持久化</span><br>save 300 10<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果60秒内,如果有10000个key进行了修改,就进行持久化</span><br>save 60 10000<br><br>stop-writes-on-bgsave-error yes #持久化如果出错了 是否还进行工作<br>rdbcompression yes #是否压缩rdb文件 这时需要消耗一些内存资源<br>rdbchecksum yes #是否校验rdb文件 会进行rdb修复<br>dbfilename dump.rdb #rdb文件名<br>dir ./  #rdb保存的目录<br></code></pre></td></tr></table></figure><blockquote><p>REPLICATION复制,主从复制</p></blockquote><blockquote><p>SECURITY 安全</p></blockquote><p>可以再这里设置redis的密码,默认是没有密码的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">redis客户端命令</span><br>config get requirepass #获取redis密码<br>config set requirepass &quot;123&quot; #设置redis密码<br>auth 123 #使用密码登录<br></code></pre></td></tr></table></figure><blockquote><p>限制CLIENT</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">maxclients 10000 #设置可以连接的最大客户端数<br>maxmemory &lt;bytes&gt; #redis配置最大的内存容量<br>maxmemory-policy noeviction #内存达到上限之后的处理策略<br></code></pre></td></tr></table></figure><blockquote><p>APPEND ONLY MODE  aof配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendonly no #默认是不开启aof模式的,默认是使用rdb方式持久化的,在大部分情况下都是使用rdb<br>appendfilename &quot;appendonly.aof&quot; #持久化的文件名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">appendfsync always <span class="hljs-comment">#每次修改都同步,消耗性能</span></span><br>appendfsync everysec #每秒执行一次同步,可能会丢失这1s得数据<br><span class="hljs-meta prompt_"># </span><span class="language-bash">appendfsync no <span class="hljs-comment">#不执行同步,操作系统自己同步数据,数据是最快的</span></span><br></code></pre></td></tr></table></figure><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><blockquote><p>rdb触发机制</p></blockquote><p>1.save的规则满足的情况下,会自动触发rdb规则</p><p>2.执行flushall命令,也会触发rdb规则</p><p>3.退出redis,也会产生rdb文件</p><p>备份就自动挡生成一个dump.rdb</p><blockquote><p>如何恢复rdb文件</p></blockquote><p>1.只需要将rdb文件放在redis启动目录就可以了,redis启动的时候就会自动检查dump.rdb恢复其中的数据</p><p>2.查看需要保存的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">redis客户端</span><br>config get dir<br></code></pre></td></tr></table></figure><p><strong>优点:</strong></p><p>1.适合大规模的数据恢复</p><p>2.对数据的完整性要求不高</p><p><strong>缺点:</strong></p><p>1.需要一定的时间间隔进行操作,如果redis意外宕机了,最后一次的修改数据就没有了</p><p>2.fork进程的时候,会占用一定的内存空间</p><h4 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h4><p>将我们的所有命令都记录下来,像history命令,将执行的命令全部都执行一遍</p><p>只记录写的命令,读取的命令不记录</p><p>该模式默认是不开启的,我们需要进行手动配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendonly no #默认是不开启的,yes表示开启<br></code></pre></td></tr></table></figure><p><strong>aof的文件默认为appendonly.aof</strong></p><p>如果aof文件有错位,redis就启动不起来了,我们需要通过工具修复</p><p>redis-check-aof –fix appendonly.aof</p><p>重启就能恢复正常</p><blockquote><p>aof的优点和缺点</p></blockquote><p><strong>优点</strong></p><p>1.每一次修改都同步,文件的完整性会更好</p><p>2.每秒同步一次, 可能会丢失一秒的数据</p><p>3.从不同步,效率是最高的</p><p><strong>缺点</strong></p><p>1.相对于数据文件来说aof远远大于rdb,修复的速度也比rdb慢</p><p>2.aof的运行效率也比rdb慢,所以redis默认的配置是rdb持久化</p><h2 id="redis订阅发布"><a href="#redis订阅发布" class="headerlink" title="redis订阅发布"></a>redis订阅发布</h2><p>redis发布订阅(pub&#x2F;sub)是一种<strong>消息通信模式</strong>:发布者(pub)发送消息,订阅者(sub)接收消息.微博,微信,关注系统</p><p>redis客户端可以订阅仁义数量的频道.</p><p>订阅者:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; SUBSCRIBE zhengge #订阅一个通道<br>Reading messages... (press Ctrl-C to quit)<br>1) &quot;subscribe&quot;<br>2) &quot;zhengge&quot;<br>3) (integer) 1<br>1) &quot;message&quot;<br>2) &quot;zhengge&quot;<br>3) &quot;nihao&quot;<br>1) &quot;message&quot;<br>2) &quot;zhengge&quot;<br>3) &quot;sdsdf&quot;<br></code></pre></td></tr></table></figure><p>发送端:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; PUBLISH zhengge &quot;nihao&quot; #指定订阅发布消息<br>(integer) 1<br>127.0.0.1:6379&gt; PUBLISH zhenge sdsdf<br>(integer) 0<br>127.0.0.1:6379&gt; PUBLISH zhengge sdsdf<br>(integer) 1<br></code></pre></td></tr></table></figure><p>通过subscribe命令订阅某频道后,redis-server里维护了一个字典,字典的键就是一个个频道,而字典的值则是一个链表,链表中保存了所有订阅这个channel的客户端,subscribe命令的关键,就是将客户端添加到给定channel的订阅列表中.</p><h2 id="redis主从复制-replication"><a href="#redis主从复制-replication" class="headerlink" title="redis主从复制(replication)"></a>redis主从复制(replication)</h2><p>master&#x2F;leader 主机</p><p>slave 从机</p><p>数据的赋值是单向的,只能由主节点到从节点.</p><p>主从复制,读写分离,可以减缓服务器压力,架构中常用.最低集群需要一主二从,哨兵机制需要二台以上</p><p><strong>主从复制的作用主要包括:</strong></p><p>1.数据冗余</p><p>2.故障恢复</p><p>3.负载均衡</p><p>4.高可用(集群)基石</p><p><strong>单台redis最大使用内存不超过20G</strong></p><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><hr><p>单服务器多实例: 只配置从库,不用配置主库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; info replication # 查看当前库的信息<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:master #角色<br>connected_slaves:0 #没有从机<br>master_replid:b89b5421af09a64ed749f0277e81f05a66e558c5<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure><p>复制三个配置文件,然后修改对应的信息</p><p>1.端口</p><p>2.pid名字</p><p>3.log文件名</p><p>3.dump.rdb名字</p><p>修改完毕后指定配置文件启动进程, .&#x2F;redis-server ..&#x2F;redisxxxx.conf</p><h5 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h5><hr><p><em><strong>默认情况下,每台redis服务器都是主节点</strong></em></p><p>从机认主机: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">slaveof 127.0.0.1 6379<br></code></pre></td></tr></table></figure><p>真实的主从配置应该在配置文件中配置,这样的话是永久的,命令是暂时的</p><blockquote><p>细节</p></blockquote><p>主机才能写,从机只能读.主机中的所有信息和数据,都会被从机复制</p><p>如果是使用命令行配置的主从,重启,从机会默认变成主机,只要变为从机,立马就能获得主机的值</p><blockquote><p>复制原理</p></blockquote><p>slave启动成功链接master后会发送一个sync同步命令</p><p>master接到命令,启动后台的存盘进程,同时手机所有接收到的用于修改数据集命令,再后台进程执行完毕之后,<em><strong>master将传送整个数据文件到slave,并完成一次完全同步.</strong></em></p><p>全量复制: slave服务再接收到数据库文件数据后,将其存盘并加载到内存</p><p>增量复制: master继续将新的所有收集到的修改命令一次传给slave,完成同步</p><p>但是只要是重新链接master,一次完全同步(增量复制)将被自动执行</p><blockquote><p>多层链路</p></blockquote><p>上一个master链接slave</p><p><img src="/image/postImage/image-20210409150642504.png"></p><p>此时81节点还是为slave,所以依然不能写入,但是为82的master</p><p>81同步80数据,82同步81数据</p><p>如果80宕机,使用命令  SLAVEOF no one 可以使用81变为master.其他节点就可以手动链接导最新的主节点</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>(自动选举老大的模式)</p><p>redis从2.8开始正式提供了sentinel(哨兵)架构来解决这个问题</p><p>&#x3D;&#x3D;自动将从库转换为主库&#x3D;&#x3D;</p><p> 哨兵模式是一种特殊的模式,首先redis提供了哨兵的命令,哨兵是一个独立的进程,作为进程,他会独立运行.其原理是哨兵通过发送命令,等待redis服务器响应,从而监控运行的多个redis实例.</p><p><img src="/image/postImage/image-20210409153316002.png"></p><p> 哨兵有两个作用:</p><ul><li>通过发送命令,让redis服务器返回监控其运行状态,包括主服务器和从服务</li><li>当哨兵检查导master宕机,会自动将slave切换成master,然后通过发布订阅模式同事其他的从服务器,修改配置文件,让他们切换主机.</li></ul><p>然而一个哨兵进程对redis服务器进行监控,可能会出现问题,为此,我们可以使用多个哨兵进行监控.各个哨兵之间还会进行监控,这样就形成了多哨兵模式.</p><p><img src="/image/postImage/image-20210409153706360.png"></p><p>假设主服务器宕机,哨兵1先检查导这个结果.系统并不会马上进行failover过程,仅仅是哨兵1主观的认为主服务器不可用,这个现象称为<em><strong>主观下线</strong></em>.当后面的哨兵也检测到主服务器不可用,并且数量达到一定值时,那么哨兵之间就会进行一次投票,投票的结果由一个哨兵发起,进行failover[故障转移]操作.切换成功后,就会通过发布订阅通知,让各个哨兵把自己监控的从服务器实现切换主机,这个过程成为<em><strong>客观下线</strong></em>.</p><blockquote><p>测试</p></blockquote><p>1.配置哨兵配置文件sentinel.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">sentinel monitor 被监控的名称 host post 1</span><br>sentinel monitor myredis 127.0.0.1 6379 1<br></code></pre></td></tr></table></figure><p>后面的这个数字1代表,主机宕机,slave投票看让谁接替成为主机,票数最多的就会成为主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">启动sentinel</span><br>./redis-server ../sentinel.conf<br></code></pre></td></tr></table></figure><p>如果主机回来了,只能归并到新的主机下,当做从机,这就是哨兵模式的规则</p><blockquote><p>哨兵模式</p></blockquote><p>优点:</p><p>1.哨兵集群,基于的主从复制模式,所有的主从配置有点,他全有</p><p>2.主从可以切换,故障可以转移,系统的可用性就会更好</p><p>3.哨兵模式就是主从模式的升级,从手动到自动,更加健壮</p><p>缺点:</p><p>1.redis不好在线扩容,集群容量一旦到达上线,在线扩容就十分麻烦</p><p>2.实现哨兵模式的配置其实是很麻烦,里面有很多选择</p><h2 id="redis缓存穿透和雪崩"><a href="#redis缓存穿透和雪崩" class="headerlink" title="redis缓存穿透和雪崩"></a>redis缓存穿透和雪崩</h2><blockquote><p>服务的高可用</p></blockquote><h4 id="缓存穿透-查不到"><a href="#缓存穿透-查不到" class="headerlink" title="缓存穿透(查不到)"></a>缓存穿透(查不到)</h4><blockquote><p>概念</p></blockquote><p>用户想要查询一个数据,缓存中没有命中,持久层也没有命中.然后多次重复查询持久层,造成持久层压力过大,这时就出现了缓存穿透.</p><blockquote><p>解决方案</p></blockquote><p>布隆过滤器</p><p>布隆过滤器是一种数据结构,对所有可能查询的参数以hash形式存储,在控制层先进行校验,不符合则丢弃.从而避免了对底层存储系统的查询压力</p><p><img src="/image/postImage/image-20210409173905051.png"></p><p>缓存空对象</p><p>当存储层不命中后,即使返回的空对象也将其缓存起来,同时会设置一个过期时间,之后再访问这个数据将会从缓存中获取,保护了后端数据源</p><p><img src="/image/postImage/image-20210409174028930.png"></p><p>但是这种方法会存在两个问题:</p><p>1.如果空值能够被缓存起来,这就意味着缓存需要更多的空间存储更多的键,因为当中可能会有很多的空值的键</p><p>2.即使对空值设置了过期时间,还是会存在缓存层和存储层的数据会有一段时间不一致,这对于需要保持一致的业务会有影响</p><h4 id="缓存击穿-量太大-缓存过期"><a href="#缓存击穿-量太大-缓存过期" class="headerlink" title="缓存击穿(量太大,缓存过期)"></a>缓存击穿(量太大,缓存过期)</h4><blockquote><p>概念</p></blockquote><p>某个key非常热点,在不断的扛着大并发,大并发集中对这个点进行访问,当这个key在是失效的瞬间,持续的大并发就会穿破缓存,直接请求数据库.</p><p>当key在过期瞬间,有大量的请求并发访问.这类数据一般是热点数据,由于缓存过期,会同时访问数据库来查询最新的数据,并且回写缓存,会导致数据库瞬间压力过大</p><blockquote><p>解决方案</p></blockquote><p><em><strong>设置热点数据不过期</strong></em></p><p>从缓存的层面来看,没有设置过期时间,所以不会出现热点key过期后产生的问题</p><p><em><strong>加互斥锁</strong></em></p><p>分布式锁:使用分布式锁,保证对于每个key同时只能有一个线程去查询后端服务,其他线程没有获得分布式锁的权限,因此只需要等待即可.这种方式将高并发的压力转移到了分布式锁,因此对分布式锁的考验很大</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><blockquote><p>概念</p></blockquote><p>缓存雪崩,是指在某一个时间段,缓存集中过期,redis宕机</p><blockquote><p>解决方式</p></blockquote><p><strong>redis高可用</strong></p><p>这个思想的意义是,既然redis有可能挂掉,那我就多增设几台reids,这样一台挂掉之后其他的还可以继续工作,其实就是搭建集群(异地多活)</p><p><strong>限流降级</strong></p><p>这个解决方案的思路,在缓存实现后,通过加锁或者队列来控制杜数据库写缓存的线程数量.比如对某个key只允许一个线程查询数据和写缓存,其他线程等待.</p><p><strong>数据预热</strong></p><p>在正式部署之前,把可能的数据先预先访问一遍,这样部分可能大量访问的数据就会加载导缓存中,在即将发生大并发访问前手动触发加载缓存不同的key,设置不同的过期时间,让缓存失效的时间点尽量均匀</p>]]></content>
    
    
    <categories>
      
      <category>📦DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(📦DB) Mysql事务隔离级别</title>
    <link href="/2024/07/04/Mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2024/07/04/Mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="三种数据库读取时会发生的情况"><a href="#三种数据库读取时会发生的情况" class="headerlink" title="三种数据库读取时会发生的情况:"></a>三种数据库读取时会发生的情况:</h4><ul><li><p>脏读: A读取到了B未提交的数据</p></li><li><p>不可重复读: A重复读读取一个数据,B在读取时对数据发生修改,导致A读取数据发生变化</p></li><li><p>幻读: A在对数据进行修改时,B同时对数据进行了插入或删除操作,导致A的处理结果受到影响(结果不到预期,就想产生了幻觉)</p></li></ul><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别:"></a>四种隔离级别:</h4><ul><li><p>读未提交 read-uncommitted 脏读,不可重复读,幻读 会发生</p></li><li><p>不可重复读 read-committed 不可重复读,幻读 会发生</p></li><li><p>可重复读 repeatable-read 幻读 会发生</p></li><li><p>串行化 serializable 脏读 不可重复读 幻读 不会发生</p></li></ul><p>解决幻读需要进行表锁</p><p>解决不可重复读需要进行行锁</p>]]></content>
    
    
    <categories>
      
      <category>📦DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(📦DB) Mysql建立索引的几个原则</title>
    <link href="/2024/07/04/Mysql%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%88%99/"/>
    <url>/2024/07/04/Mysql%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h5 id="1-选择唯一性索引"><a href="#1-选择唯一性索引" class="headerlink" title="1.选择唯一性索引"></a>1.选择唯一性索引</h5><p>唯一性索引的值是唯一的,可以更快速的通过该索引来确定某条记录.如果使用非唯一性字段,会降低查询速度</p><h5 id="2-为经常需要排序-分组和联合操作的字段建立索引"><a href="#2-为经常需要排序-分组和联合操作的字段建立索引" class="headerlink" title="2.为经常需要排序&#x2F;分组和联合操作的字段建立索引"></a>2.为经常需要排序&#x2F;分组和联合操作的字段建立索引</h5><p>经常需要order by,group by ,distinct和union等操作的字段,排序操作会浪费很多时间.如果为其建立索引,可以有效的避免排序操作.</p><h5 id="3-为常作为查询条件的字段建立索引"><a href="#3-为常作为查询条件的字段建立索引" class="headerlink" title="3.为常作为查询条件的字段建立索引"></a>3.为常作为查询条件的字段建立索引</h5><p>如果某个字段经常用来做查询,那么该字段的查询速度会影响整个表的查询速度.因此,为这样的字段的建立索引,可以提高整个表的查询速度.</p><h5 id="4-限制索引的数目"><a href="#4-限制索引的数目" class="headerlink" title="4.限制索引的数目"></a>4.限制索引的数目</h5><p>索引的数目不是越多越好,每个索引都需要占用磁盘空间,索引越多,需要的磁盘空间就越大.修改表时,对索引的重构和更新都很麻烦.越多的索引,会使更新表变得很浪费时间.</p><h5 id="5-尽量使用数据量少的索引"><a href="#5-尽量使用数据量少的索引" class="headerlink" title="5.尽量使用数据量少的索引"></a>5.尽量使用数据量少的索引</h5><p>如果索引的值很长,那么查询的速度会受到影响.</p><h5 id="6-尽量使用前缀来索引"><a href="#6-尽量使用前缀来索引" class="headerlink" title="6.尽量使用前缀来索引"></a>6.尽量使用前缀来索引</h5><p>如果索引字段的值很长,最好使用值的前缀来索引.例如,TEXT和BLOG类型的字段,进行全文检索会浪费时间.如果只检索字段的前面的若干个字符,这样可以提高检索速度.</p><h5 id="7-删除不再使用或者很少使用的索引"><a href="#7-删除不再使用或者很少使用的索引" class="headerlink" title="7.删除不再使用或者很少使用的索引"></a>7.删除不再使用或者很少使用的索引</h5><p>表中的数据被大量更新,或者数据的使用方式被改变后,原来的一些索引可能不再需要.应当定期删除这些不需要的索引,从而减少索引对更新操作的影响.</p><h5 id="8-最左前缀匹配原则-非常重要的原则"><a href="#8-最左前缀匹配原则-非常重要的原则" class="headerlink" title="8.最左前缀匹配原则,非常重要的原则"></a><font color="red">8.最左前缀匹配原则,非常重要的原则</font></h5><p>mysql会一直向右匹配直到遇到范围查询(&gt;,&lt;,between,like)就停止匹配,如果建立的索引(a,b,c,d),条件为a&#x3D;”x” and b&#x3D;”x” and c &gt; “x” and d &#x3D; “x”,那么d是用不到索引</p><h5 id="9-和in可以乱序"><a href="#9-和in可以乱序" class="headerlink" title="9.&#x3D;和in可以乱序"></a>9.&#x3D;和in可以乱序</h5><p>比如a&#x3D;1 and b&#x3D;2 and c&#x3D;3建立(a,b,c)索引可以任意顺序,mysql的查询优化器会帮你优化成索引可以识别的形式</p><h5 id="10-尽量选择区分度高的列作为索引"><a href="#10-尽量选择区分度高的列作为索引" class="headerlink" title="10.尽量选择区分度高的列作为索引"></a>10.尽量选择区分度高的列作为索引</h5><p>区分度的公式是count(distinct col)&#x2F;count(*),表示字段不重复的比例,比例越大我们扫描的记录数越少,唯一键的区分度是1,而一些状态,性别字段可能在大数据面前区分度就是0</p><h5 id="11-索引列不参与计算-保持列”干净”"><a href="#11-索引列不参与计算-保持列”干净”" class="headerlink" title="11.索引列不参与计算,保持列”干净”"></a>11.索引列不参与计算,保持列”干净”</h5><p>b+树中存的都是数据表中的字段值,但进行索引时,需要把所有元素都应用函数才能比较,显然成本太大</p><h5 id="12-尽量的扩展索引-不要新建索引"><a href="#12-尽量的扩展索引-不要新建索引" class="headerlink" title="12.尽量的扩展索引,不要新建索引"></a>12.尽量的扩展索引,不要新建索引</h5><p>比如表中已经有a的索引,现在要加(a,b)的索引,那么只需要修改原来的索引即可</p><h5 id="13-当单个索引字段查询数据很多-区分度都不是很大时-则需要考虑建立联合索引来提高查询效率"><a href="#13-当单个索引字段查询数据很多-区分度都不是很大时-则需要考虑建立联合索引来提高查询效率" class="headerlink" title="13.当单个索引字段查询数据很多,区分度都不是很大时,则需要考虑建立联合索引来提高查询效率"></a>13.当单个索引字段查询数据很多,区分度都不是很大时,则需要考虑建立联合索引来提高查询效率</h5>]]></content>
    
    
    <categories>
      
      <category>📦DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(📒Note) lidll-M问题记录</title>
    <link href="/2024/07/04/lidll-M%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/07/04/lidll-M%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>1.SpringBoot项目静态资源路径问题:</p><p>静态资源访问需要使用模板引擎,选用<code>shymeleaf</code>模板引擎,用于通过请求跳转到html页面以及页面数据处理</p><p>SpringBoot会提供一个webmvc的默认配置类<code>WebMvcAutoConfiguration</code></p><p>其中<code>WebMvcAutoConfigurationAdapter</code>实现<code>WebMvcConfigurer</code>静态类中使用的<code>WebProperties</code>参数默认配置如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//classpath表示resources目录下</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <br>  <span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>,<br><span class="hljs-string">&quot;classpath:/resources/&quot;</span>, <br>  <span class="hljs-string">&quot;classpath:/static/&quot;</span>, <br>  <span class="hljs-string">&quot;classpath:/public/&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>已经提供好了静态加载的几种默认路径.</p><p>但如果自定义实现了<code>WebMvcConfigurer</code>接口</p><p>就需要手动重写<code>addResourceHandlers</code>方法自行配置静态资源位置,如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>    <span class="hljs-comment">//表示在以&quot;/&quot;请求的路径会在自动请求资源路径&quot;/resources&quot;用来访问静态资源</span><br>      registry.addResourceHandler(<span class="hljs-string">&quot;/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/resources/&quot;</span>);<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>📒Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(🔗Git) git常用命令</title>
    <link href="/2024/07/03/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/07/03/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<pre><code class="shell">git config --global user.name &quot;xxx&quot;                       # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件git config --global color.ui true                         # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy                    # remove  proxy configuration on gitgit clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库git status                                                # 查看当前版本状态（是否修改）git add xyz                                               # 添加xyz文件至indexgit add .                                                 # 增加当前子目录下所有更改过的文件至indexgit commit -m &#39;xxx&#39;                                       # 提交git commit --amend -m &#39;xxx&#39;                               # 合并上一次提交（用于反复修改）git commit -am &#39;xxx&#39;                                      # 将add和commit合为一步git rm xxx                                                # 删除index中的文件git rm -r *                                               # 递归删除git log                                                   # 显示提交日志git log -1                                                # 显示1行日志 -n为n行git log -5git log --stat                                            # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容git show dfb02                                            # 可只用commitid的前几位git show HEAD                                             # 显示HEAD提交日志git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag                                                   # 显示已存在的taggit tag -a v2.0 -m &#39;xxx&#39;                                  # 增加v2.0的taggit show v2.0                                             # 显示v2.0的日志及详细内容git log v2.0                                              # 显示v2.0的日志git diff                                                  # 显示所有未添加至index的变更git diff --cached                                         # 显示所有已添加index但还未commit的变更git diff HEAD^                                            # 比较与上一个版本的差异git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch                                                # 显示本地分支git branch --contains 50089                               # 显示包含提交50089的分支git branch -a                                             # 显示所有分支git branch -r                                             # 显示所有原创分支git branch --merged                                       # 显示所有已合并到当前分支的分支git branch --no-merged                                    # 显示所有未合并到当前分支的分支git branch -m master master_copy                          # 本地分支改名git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy                        # 上面的完整版git checkout features/performance                         # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0                                         # 检出版本v2.0git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）git merge origin/master                                   # 合并远程master分支至当前分支git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改git push origin master                                    # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支git push --tags                                           # 把所有tag推送到远程仓库git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master                                    # 获取远程分支master并merge到当前分支git mv README README2                                     # 重命名文件README为README2git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933git ls-files                                              # 列出git index包含的文件git show-branch                                           # 图示当前分支历史git show-branch --all                                     # 图示所有分支历史git whatchanged                                           # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD                                          # 内部命令：显示某个git对象git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASHgit reflog                                                # 显示所有提交，包括孤立节点git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态git log --pretty=format:&#39;%h %s&#39; --graph                   # 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash                                                 # 暂存当前修改，将所有至为HEAD状态git stash list                                            # 查看所有暂存git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”git grep -e &#39;#define&#39; --and -e SORT_DIRENTgit gcgit fsck git init                                                  # 初始化本地git仓库（创建新仓库）</code></pre>]]></content>
    
    
    <categories>
      
      <category>🔗Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>command</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(📒Note) java.lang.OutOfMemoryError：Java_heap_space发送带有附件的邮件OOM问题</title>
    <link href="/2024/07/02/java-lang-OutOfMemoryError-Java-heap-space%E5%8F%91%E9%80%81%E5%B8%A6%E6%9C%89%E9%99%84%E4%BB%B6%E7%9A%84%E9%82%AE%E4%BB%B6OOM%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/02/java-lang-OutOfMemoryError-Java-heap-space%E5%8F%91%E9%80%81%E5%B8%A6%E6%9C%89%E9%99%84%E4%BB%B6%E7%9A%84%E9%82%AE%E4%BB%B6OOM%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="项目概况"><a href="#项目概况" class="headerlink" title="项目概况:"></a>项目概况:</h4><p>结合街道办事处日常的工作场景,以街道办管辖的社区及人员结构为基础.开发了一套”通知”,”统计”,”任务分派”等功能合集的效率办公平台.</p><p>项目部署在客户现场,两台4核16G服务器100,101ip段.</p><p>100机部署无高io应用</p><p>101机部署IO高应用及数据库</p><h4 id="起因"><a href="#起因" class="headerlink" title="起因:"></a>起因:</h4><p>客户反馈’’通知’’应用中的附件发送到邮件时提示”发送失败”.</p><h4 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题:"></a>排查问题:</h4><p>首先从报错接口定位到项目具体controller对应的方法,在日志中查看错误信息为java堆溢出错误</p><p>org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.OutOfMemoryError: Java heap space</p><p>接着检查项目代码是否存在问题,发现代码需要通过feign接口到oss服务获取文件字节码,此处有可能会出现文件过大导致接口异常或者jvm内存溢出的可能(取决于项目启动参数定义的大小与服务器的实际内存大小)</p><p>接着 查看oss服务日志,发现oss报错Caused by: java.io.IOException: Connection reset by peer</p><p>经过排查,oss异常原因是message导致的.</p><p>最后通过本地启动项目,在测试环境模拟复现问题,发现一下可能的原因:</p><p>1.feign接口日志级别 feignLogConfig,定义的级别为FULL,feign接口请求时,日志为所有内容,内容过大,传递信息过多</p><p>2.备用服务器没有外网,无法发送邮件</p><p>3.阿里云邮件服务中附件大小不能超过15M</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决:"></a>解决:</h4><p>将message服务转移到100机带有外网环境的服务器下,功能正常.</p><p>但是代码中没有做文件大小限制,需要优化</p><p>日志级别也调整到HEADER级别</p>]]></content>
    
    
    <categories>
      
      <category>📒Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
      <tag>oom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(💻️Front) vue-cli的使用</title>
    <link href="/2024/07/02/vue-cli%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/07/02/vue-cli%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="命令"><a href="#命令" class="headerlink" title="命令:"></a>命令:</h3><p>全局安装vue-cli: sudo管理员运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo npm install @vue/cli -g <br></code></pre></td></tr></table></figure><p>全局安装cli2模板:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo npm install @vue/cli-init -g <br></code></pre></td></tr></table></figure><ul><li><p>Vue CLI2初始化项目</p><p>​vue init webpack my-project</p></li><li><p>Vue CLI3初始化项目</p><p>​vue create my-proje</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>💻️Front</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>VUE</tag>
      
      <tag>vue-cli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(💻️Front) VUE初识</title>
    <link href="/2024/07/02/VUE%E5%88%9D%E8%AF%86/"/>
    <url>/2024/07/02/VUE%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一-邂逅Vuejs"><a href="#一-邂逅Vuejs" class="headerlink" title="一.邂逅Vuejs"></a>一.邂逅Vuejs</h2><h3 id="1-1认识Vuejs"><a href="#1-1认识Vuejs" class="headerlink" title="1.1认识Vuejs"></a>1.1认识Vuejs</h3><ul><li><p>为什么学习vue</p></li><li><p>vue的读音</p></li><li><p>vue的渐进式</p></li><li><p>vue的特点</p></li></ul><h3 id="1-2安装vue"><a href="#1-2安装vue" class="headerlink" title="1.2安装vue"></a>1.2安装vue</h3><ul><li>CDN引入</li><li>下载引入</li><li>npm安装</li></ul><h3 id="1-3vue的初体验"><a href="#1-3vue的初体验" class="headerlink" title="1.3vue的初体验"></a>1.3vue的初体验</h3><ul><li>hello Vuejs</li><li><ul><li>mustache &gt; 体验vue响应式</li></ul></li><li>Vue列表展示<ul><li>v-for</li><li>后面给数组追加元素的时候,新的元素也可以再界面中渲染出来</li></ul></li><li>Vue计数器小案例<ul><li>事件监听:click -&gt; methods</li></ul></li></ul><h3 id="1-4-Vue中的MVVM"><a href="#1-4-Vue中的MVVM" class="headerlink" title="1.4 Vue中的MVVM"></a>1.4 Vue中的MVVM</h3><h3 id="1-5创建vue时-options可以放哪些东西"><a href="#1-5创建vue时-options可以放哪些东西" class="headerlink" title="1.5创建vue时,options可以放哪些东西"></a>1.5创建vue时,options可以放哪些东西</h3><ul><li>el</li><li>data</li><li>method</li><li>comptued</li><li>生命周期函数</li></ul><h2 id="二-插值操作"><a href="#二-插值操作" class="headerlink" title="二.插值操作"></a>二.插值操作</h2><ul><li>muscache</li><li>v-html</li><li>v-once</li><li>v-text</li><li>v-cloak</li><li>v-pre</li></ul><h2 id="三-动态绑定"><a href="#三-动态绑定" class="headerlink" title="三.动态绑定"></a>三.动态绑定</h2><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul><li>分为 对象形式绑定 ,数组形式绑定</li></ul><h2 id="四-计算属性"><a href="#四-计算属性" class="headerlink" title="四.计算属性"></a>四.计算属性</h2><ul><li>option当中提供属性 computed,其中定义的函数将data属性中的参数进行复杂处理后方便muscache中直接引用</li><li>不同于methods属性的是,computed中的函数只会计算一次,之后使用时是读取缓存(类似于java中的static静态变量)</li></ul>]]></content>
    
    
    <categories>
      
      <category>💻️Front</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(⌨Java) Lambda表达式</title>
    <link href="/2024/07/02/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/07/02/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Java8新引入的语法糖 Lambda表达式<em>（关于lambda表达式是否属于语法糖存在很多争议，有人说他并不是语法糖，这里我们不纠结于字面表述）</em>。Lambda表达式是一种用于取代匿名类，把函数行为表述为函数式编程风格的一种匿名函数，这里再重申一下：Lambda表达式的执行结果是函数式接口的一个匿名对象（Lambda表达式的基本语法在初级课程已经讲过，在此不做赘述）。</p><h2 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h2><p>需求：遍历List集合</p><h3 id="1-1-使用Lambda表达式"><a href="#1-1-使用Lambda表达式" class="headerlink" title="1.1. 使用Lambda表达式"></a>1.1. 使用Lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>        List&lt;String&gt; strList = Arrays.asList(<span class="hljs-string">&quot;马&quot;</span>, <span class="hljs-string">&quot;士&quot;</span>, <span class="hljs-string">&quot;兵&quot;</span>);<br>        strList.forEach(s -&gt; &#123;<br>            System.out.println(s);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-使用匿名内部类"><a href="#1-2-使用匿名内部类" class="headerlink" title="1.2. 使用匿名内部类"></a>1.2. 使用匿名内部类</h3><p>那么，我们可以使用匿名内部类的形式来实现上述lambda表达式的功能，以下代码的功能一致的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>        List&lt;String&gt; strList = Arrays.asList(<span class="hljs-string">&quot;马&quot;</span>, <span class="hljs-string">&quot;士&quot;</span>, <span class="hljs-string">&quot;兵&quot;</span>);<br>        <span class="hljs-comment">//通过匿名内部类来代替lambda表达式</span><br>        strList.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>                System.out.println(s);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-示例代码分析"><a href="#2-示例代码分析" class="headerlink" title="2. 示例代码分析"></a>2. 示例代码分析</h2><p><code>forEach()</code>是<code>Iterable</code>接口的一个默认方法，它需要一个<code>Consumer</code>类型的参数，方法体中是一个for循环，对迭代器的每一个对象进行遍历，处理方法就是调用参数对象的<code>accept()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    Objects.requireNonNull(action);<br>    <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>        action.accept(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续查看<code>Consumer</code>的<code>accept(T)</code>方法，可以看到<code>Consumer</code>是一个函数式接口（只有一个抽象方法的接口，java8中称之为函数式接口），只有一个抽象方法<code>accept(T)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Performs this operation on the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the input argument</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们对照一下示例代码：</p><p><code>strList.forEach(s -&gt; &#123;System.out.println(s);&#125;);</code></p><p>可以大胆的猜测，Lambda表达式</p><p><code>s -&gt; &#123;System.out.println(s);&#125;</code>相当于是实现了<code>Consumer</code>接口的一个匿名（内部类）对象，</p><p>而大括号里面的内容：<code>System.out.println(s);</code>相当于重写了<code>accept()</code>的方法体。</p><p>当然，事情远远没有这么简单（想要直接看结论的童鞋请跳转本节最后）。</p><h2 id="3-反编译lambda表达式代码"><a href="#3-反编译lambda表达式代码" class="headerlink" title="3. 反编译lambda表达式代码"></a>3. 反编译lambda表达式代码</h2><blockquote><p>对包含lambda表达式的class文件进行反编译时需要注意：</p><p>jad系列的反编译工具不支持jdk1.8，所以这里使用CFR进行反编译。</p><p><a href="http://www.benf.org/other/cfr/">cfr下载地址</a>:<a href="http://www.benf.org/other/cfr/">http://www.benf.org/other/cfr/</a></p><p>语法：<code>java -jar cfr-0.145.jar LambdaTest.class --decodelambdas false</code></p></blockquote><p>反编译后可以得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.lang.invoke.LambdaMetafactory;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String ... args)</span> &#123;<br>        List&lt;String&gt; strList = Arrays.asList(<span class="hljs-string">&quot;马&quot;</span>, <span class="hljs-string">&quot;士&quot;</span>, <span class="hljs-string">&quot;兵&quot;</span>);<br>        strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, (Ljava/lang/Object;)V, lambda$main$<span class="hljs-number">0</span>(java.lang.String ), (Ljava/lang/String;)V)());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-comment">/* synthetic */</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>(String s) &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在<code>forEach()</code>方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory()</code>方法，该方法的第5个参数<code>implMethod</code>指定了方法实现。可以看到这里其实是调用<code>lambda$main$0()</code>方法进行输出。跟踪<code>metafactory()</code>方法（参数较多，可以跳过）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CallSite <span class="hljs-title function_">metafactory</span><span class="hljs-params">(</span><br><span class="hljs-params">    // 调用者（LambdaTest）可访问权限的上下文对象，JVM自动填充</span><br><span class="hljs-params">    MethodHandles.Lookup caller, </span><br><span class="hljs-params">    // 要执行的方法名，即Consumer.accept()</span>，JVM自动填充<br>    String invokedName,<br>    <span class="hljs-comment">// 调用点预期的签名（包含目标方法参数类型String和Lambda返回类型Consumer），JVM自动填充</span><br>    MethodType invokedType,<br>    <span class="hljs-comment">// 函数式接口抽象方法的签名， (Object)void，泛型String被擦出，所以是Object</span><br>    MethodType samMethodType,<br>    <span class="hljs-comment">// 直接方法句柄，真正被调用的方法，即lambda$main$0，签名为MethodHandle(String)void</span><br>    MethodHandle implMethod,<br>    <span class="hljs-comment">// 实例化的方法签名，即调用时动态执行的方法签名，</span><br>    <span class="hljs-comment">// 可能与samMethodType相同，也可能包含了泛型的具体类型，比如(String)void</span><br>    MethodType instantiatedMethodType) <span class="hljs-keyword">throws</span> LambdaConversionException &#123;<br>    AbstractValidatingLambdaMetafactory mf;<br>    mf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClassLambdaMetafactory</span>(caller, invokedType,<br>                                         invokedName, samMethodType,<br>                                         implMethod, instantiatedMethodType,<br>                                         <span class="hljs-literal">false</span>, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);<br>    mf.validateMetafactoryArgs();<br>    <span class="hljs-keyword">return</span> mf.buildCallSite();<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>new InnerClassLambdaMetafactory</code>看起来是创建了一个Lambda相关的<em>内部类</em>，继续跟踪下去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">InnerClassLambdaMetafactory</span><span class="hljs-params">(...)</span><br>            <span class="hljs-keyword">throws</span> LambdaConversionException &#123;<br>        <span class="hljs-comment">//....</span><br>        lambdaClassName = targetClass.getName().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-string">&quot;$$Lambda$&quot;</span> + counter.incrementAndGet();<br>        cw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);<br>       <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（省略了一部分代码。）</p><p>一看到<code>lambdaClassName</code>这样的变量名就知道它代表的什么意思——Lambda表达式对应的类名，而<code>ClassWriter</code>对象<code>cw</code>，暴露了Lambda表达式的底层实现机制：ASM技术（Assembly，<a href="https://asm.ow2.io/">Java字节码操作和分析框架</a>，用于在程序运行时动态生成和操作字节码文件）。在这个构造方法里，初始化了大量的ASM技术需要的成员变量，为后续生成字节码的相关操作完成了一系列的初始化动作。现在大致可以猜测：Lambda表达式底层是通过一个内部类来实现的，这个类由ASM技术在程序运行时动态生成，它实现了函数式接口（例如Consumer等），并重写了对应的抽象方法（如accept）。</p><h2 id="4-验证猜想"><a href="#4-验证猜想" class="headerlink" title="4. 验证猜想"></a>4. 验证猜想</h2><p>回到<code>metafactory()</code>方法中，跟踪方法结尾的返回语句<code>mf.buildCallSite();</code>——创建调用点，这才是重点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Build the CallSite. Generate a class file which implements the functional</span><br><span class="hljs-comment">    * interface, define the class, if ...</span><br><span class="hljs-comment">    * 创建调用点。定义一个实现了函数式接口的类并生成它的类文件，</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> a CallSite, which, when invoked, will return an instance of the</span><br><span class="hljs-comment">    * functional interface</span><br><span class="hljs-comment">    * 返回一个调用点，当它执行的时候，将会返回一个函数式接口（Consumer）的实例</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Override</span><br>   CallSite <span class="hljs-title function_">buildCallSite</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LambdaConversionException &#123;<br>       <span class="hljs-keyword">final</span> Class&lt;?&gt; innerClass = spinInnerClass();<br>       <span class="hljs-comment">// 省略部分代码...</span><br>       <br>       <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-type">Object</span> <span class="hljs-variable">inst</span> <span class="hljs-operator">=</span> ctrs[<span class="hljs-number">0</span>].newInstance();<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantCallSite</span>(MethodHandles.constant(samBase, inst));<br>           &#125;<br>       <span class="hljs-comment">// ...</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>方法的注释非常清晰的告诉我们，这个方法在<em>运行期</em>会返回一个函数式接口的实例，也就是<code>Consumer</code>接口的匿名对象。</p><p>方法体的第一行<code>spinInnerClass()</code>，就使用ASM技术生成了一个Class文件，然后使用<code>sun.misc.Unsafe</code>将该类加载到JVM（创建并返回该类的Class对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassWriter cw;                    <span class="hljs-comment">// ASM class writer</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Generate a class file which implements the functional</span><br><span class="hljs-comment">    * interface, define and return the class.</span><br><span class="hljs-comment">    * 生成一个实现函数式接口的类文件，定义并返回该类的Class实例</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> a Class which implements the functional interface</span><br><span class="hljs-comment">    * 返回一个实现函数式接口的Class实例</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> Class&lt;?&gt; spinInnerClass() <span class="hljs-keyword">throws</span> LambdaConversionException &#123;<br>       <span class="hljs-comment">// ....</span><br>       <span class="hljs-comment">// ClassWriter通过visit方法动态构造类的字节码</span><br>       cw.visit(, , lambdaClassName, <span class="hljs-literal">null</span>, , interfaces); <span class="hljs-comment">// 生成接口字节码</span><br>       <span class="hljs-comment">// ...</span><br>       <span class="hljs-keyword">for</span> ( ; ; ) &#123;<br>           cw.visitField( , , , <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 生成域的字节码</span><br>       &#125;<br>       generateConstructor(); <span class="hljs-comment">// 生成构造器字节码</span><br>       <span class="hljs-comment">// ...</span><br>       cw.visitMethod( ,  , , <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 生成普通方法字节码</span><br>       <span class="hljs-comment">// ...</span><br>       cw.visitEnd(); <span class="hljs-comment">// end</span><br><br>       <span class="hljs-comment">// Define the generated class in this VM.</span><br><br>       <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] classBytes = cw.toByteArray();<br>       <br>       <span class="hljs-comment">// If requested, dump out to a file for debugging purposes</span><br>       <span class="hljs-keyword">if</span> (dumper != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 转储对象</span><br>           AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>               <span class="hljs-meta">@Override</span><br>               <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                   dumper.dumpClass(lambdaClassName, classBytes);<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>               &#125;<br>           &#125;, <span class="hljs-literal">null</span>,<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilePermission</span>(<span class="hljs-string">&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;</span>, <span class="hljs-string">&quot;read, write&quot;</span>),<br>           <span class="hljs-comment">// createDirectories may need it</span><br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyPermission</span>(<span class="hljs-string">&quot;user.dir&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>));<br>       &#125;<br><span class="hljs-comment">// 使用Unsafe对象定义并返回该内部类字节码文件对象（Class）</span><br>       <span class="hljs-keyword">return</span> UNSAFE.defineAnonymousClass(targetClass, classBytes, <span class="hljs-literal">null</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>这个方法的后半部分，<code>if (dumper != null)</code> 代码块给我们提供了将该内部类转储到本地磁盘用以调试的可能，在<code>LambdaTest</code>的<code>main</code>方法里里添加一行代码，将Lambda表达式对应的内部类转储到指定目录（IDEA）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.setProperty(<span class="hljs-string">&quot;jdk.internal.lambda.dumpProxyClasses&quot;</span>, <span class="hljs-string">&quot;out/production/&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>程序运行之后</strong>，会将Lambda表达式对应的内部类文件生成出来<code>com.boxuegu.intermediate.language.sugar.lambda.LambdaTest$$Lambda$1</code>：</p><!-- ![1560239569399](D:/工作/03_资料/lambda表达式对应的内部类.png) --><p>反编译这个类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.invoke.LambdaForm;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaTest$$Lambda$1</span><br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">Consumer</span> &#123; <span class="hljs-comment">// 实现函数式接口</span><br>    <span class="hljs-keyword">private</span> LambdaTest$$Lambda$<span class="hljs-number">1</span>() &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@LambdaForm</span>.Hidden<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Object object)</span> &#123; <span class="hljs-comment">// 重写抽象方法</span><br>        LambdaTest.lambda$main$<span class="hljs-number">0</span>((String)object);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Bingo！</p><p>现在我们初步得到了一些结论：</p><blockquote><ol><li>Lambda表达式底层是用内部类来实现的 </li><li>该内部类实现了<em>某个（根据Lambda所属的代码指定）</em>函数式接口，并重写了该接口的抽象方法</li><li>该内部类是在程序运行时使用ASM技术动态生成的，所以编译期没有对应的.class文件，但是我们可以通过设置系统属性将该内部类文件转储出来</li></ol></blockquote><h2 id="5-Lambda表达式编译和运行过程"><a href="#5-Lambda表达式编译和运行过程" class="headerlink" title="5. Lambda表达式编译和运行过程"></a>5. Lambda表达式编译和运行过程</h2><p>至此，我们只窥视了Lambda表达式底层实现的冰山一角。接下来会有一堆概念和过程，慎入！</p><!-- ![1560239569399](D:/工作/03_资料/Lambda表达式编译和运行过程.png) --><ol><li>Java7在<a href="https://jcp.org/en/jsr/detail?id=292">JSR（Java Specification Requests，Java 规范提案） 292</a>中增加了对动态类型语言的支持，使得Java也可以像<em>C语言</em>那样将方法作为参数传递，其实现在<code>java.lang.invoke</code>包中。它的核心就是<code>invokedynamic</code>指令，为后面<strong>函数式编程</strong>和<strong>响应式编程</strong>提供了前置支持。</li><li><code>invokedynamic</code>指令对应的执行方法会关联到一个<em>动态</em>调用点对象（<code>java.lang.invoke.CallSite</code>），一个调用点（call site）是一个方法句柄（method handle，调用点的目标）的持有者，这个调用点对象会指向一个具体的引导方法（bootstrap method，比如<code>metafactory()</code>），引导方法成功调用之后，调用点的目标将会与它持有的方法句柄的引用永久绑定，最终得到一个实现了函数式接口（比如Consumer）的对象。</li><li>Lambda表达式在编译期进行脱糖（desugar），它的主体部分会被转换成一个脱糖方法（desugared method，即<code>lambda$main$0</code>），这是一个合成方法，如果Lambda没有用到外部变量，则是一个私有的静态方法，否则将是个私有的实例方法——synthetic 表示不在源码中显示，并在Lambda所属的方法（比如main方法）中生成<code>invokedynamic</code>指令。</li><li><strong>进入运行期</strong>，<code>invokedynamic</code>指令会调用引导方法<code>metafactory()</code>初始化ASM生成内部类所需的各项属性，然后由<code>spinInnerClass()</code>方法组装内部类并用Unsafe加载到JVM，通过构造方法实例化内部类的实例（Lambda的实现内部类的构造是私有的，需要手动设置可访问属性为true），最后绑定到方法句柄，完成调用点的创建。</li><li>你可以把调用点看成是函数式接口（例如Consumer等）的匿名对象，当然，内部类是确实存在的——比如<code>final class LambdaTest$$Lambda$1 implements Consumer</code>。值得注意的是，内部类的实现方法里并没有Lambda表达式的任何操作，它不过是调用了脱糖后定义在调用点目标类（<code>targetClass</code>，即<code>LambdaTest</code>类）中的合成方法（即<code>lambda$main$0</code>）而已，这样做使得内部类的代码量尽可能的减少，降低内存占用，对效率的提升更加稳定和可控。</li></ol><h2 id="6-Lambda表达式的语法糖结论"><a href="#6-Lambda表达式的语法糖结论" class="headerlink" title="6. Lambda表达式的语法糖结论"></a>6. Lambda表达式的语法糖结论</h2><p>Lambda表达式在编译期脱去糖衣语法，生成了一个“合成方法”，在运行期，<code>invokedynamic</code>指令通过引导方法创建调用点，过程中生成一个实现了函数式接口的内部类并返回它的对象，最终通过调用点所持有的方法句柄完成对合成方法的调用，实现具体的功能。</p><p>Lambda表达式是一个语法糖，但远远不止是一个语法糖。</p><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</p><h2 id="1-冗余的Lambda场景"><a href="#1-冗余的Lambda场景" class="headerlink" title="1.冗余的Lambda场景"></a>1.冗余的Lambda场景</h2><p>来看一个简单的函数式接口以应用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Printable</span>&#123;<br>    voidprint(Stringstr);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Printable</code>接口当中唯一的抽象方法<code>print</code>接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01PrintSimple</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printString</span><span class="hljs-params">(Printable data)</span> &#123;<br>    data.print(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    printString(s ‐&gt; System.out.println(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>printString</code> 方法只管调用 <code>Printable</code> 接口的 <code>print</code> 方法，而并不管 print 方法的具体实现逻辑会将字符串打印到什么地方去。而 <code>main</code> 方法通过Lambda表达式指定了函数式接口 <code>Printable</code> 的具体操作方案为：<strong>拿到</strong><code>String</code>（类型可推导，所以可省略）数据后，在控制台中输出它。 </p><h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h2><p>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 <code>System.out</code>对象中的 <code>println(String)</code> 方法。既然Lambda希望做的事情就是调用 <code>println(String)</code> 方法，那何必自己手动调用呢？</p><h2 id="3-用方法引用改进代码"><a href="#3-用方法引用改进代码" class="headerlink" title="3. 用方法引用改进代码"></a>3. 用方法引用改进代码</h2><p>能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02PrintRef</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printString</span><span class="hljs-params">(Printable data)</span> &#123;<br>    data.print(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    printString(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意其中的<code>双冒号 ::</code> 写法，这被称为“方法引用”，而双冒号是一种新的语法。</p><h2 id="4-方法引用符"><a href="#4-方法引用符" class="headerlink" title="4. 方法引用符"></a>4. 方法引用符</h2><p>双冒号 <code>::</code> 为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>例如上例中， <code>System.out</code> 对象中有一个重载的 <code>println(String)</code> 方法恰好就是我们所需要的。那么对于<br><code>printString</code> 方法的函数式接口参数，对比下面两种写法，完全等效：</p><ul><li>Lambda表达式写法： <code>s -&gt; System.out.println(s);</code></li><li>方法引用写法： <code>System.out::println</code></li></ul><p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给 <code>System.out.println</code> 方法去处理。<br>第二种等效写法的语义是指：直接让 <code>System.out</code> 中的 <code>println</code> 方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</p><blockquote><p>注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p></blockquote><h3 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h3><p>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都<br>将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。</p><p>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。<br>下面这段代码将会调用 <code>println</code> 方法的不同重载形式，将函数式接口改为int类型的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PrintableInteger</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> str)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03PrintOverload</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInteger</span><span class="hljs-params">(PrintableInteger data)</span> &#123;<br>    data.print(<span class="hljs-number">1024</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    printInteger(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次方法引用将会自动匹配到 <code>println(int)</code> 的重载形式。</p><h2 id="5-通过对象名引用成员方法"><a href="#5-通过对象名引用成员方法" class="headerlink" title="5. 通过对象名引用成员方法"></a>5. 通过对象名引用成员方法</h2><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodRefObject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printUpperCase</span><span class="hljs-params">(String str)</span> &#123;<br>    System.out.println(str.toUpperCase());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数式接口仍然定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Printable</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么当需要使用这个 <code>printUpperCase</code> 成员方法来替代 <code>Printable</code> 接口的Lambda的时候，已经具有了<br><code>MethodRefObject</code> 类的对象实例，则可以通过对象名引用成员方法，代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04MethodRef</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printString</span><span class="hljs-params">(Printable lambda)</span> &#123;<br>    lambda.print(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MethodRefObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodRefObject</span>();<br>        printString(obj::printUpperCase);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-通过类名称引用静态方法"><a href="#6-通过类名称引用静态方法" class="headerlink" title="6. 通过类名称引用静态方法"></a>6. 通过类名称引用静态方法</h2><p>由于在 <code>java.lang.Math</code> 类中已经存在了静态方法 <code>abs</code> ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calcable</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>第一种写法是使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05Lambda</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> num, Calcable lambda)</span> &#123;<br>    System.out.println(lambda.calc(num));<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    method(‐<span class="hljs-number">10</span>, n ‐&gt; Math.abs(n));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是使用方法引用的更好写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06MethodRef</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> num, Calcable lambda)</span> &#123;<br>    System.out.println(lambda.calc(num));<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    method(‐<span class="hljs-number">10</span>, Math::abs);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>n -&gt; Math.abs(n)</code></li><li>方法引用： <code>Math::abs</code></li></ul><h2 id="7-通过super引用成员方法"><a href="#7-通过super引用成员方法" class="headerlink" title="7. 通过super引用成员方法"></a>7. 通过super引用成员方法</h2><p>如果存在继承关系，当Lambda中需要出现<code>super</code>调用时，也可以使用方法引用进行替代。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Greetable</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">greet</span><span class="hljs-params">()</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>然后是父类 Human 的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是子类 <code>Man</code> 的内容，其中使用了Lambda的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;大家好,我是Man!&quot;</span>);<br>    &#125;<br><br>     <span class="hljs-comment">// 定义方法method,参数传递Greetable接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Greetable g)</span>&#123;<br>    g.greet();<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 调用method方法,使用Lambda表达式</span><br>        method(()‐&gt;&#123;<br>        <span class="hljs-comment">// 创建Human对象,调用sayHello方法</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>().sayHello();<br>        &#125;);<br>        <span class="hljs-comment">// 简化Lambda</span><br>        method(()‐&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>().sayHello());<br>        <span class="hljs-comment">// 使用super关键字代替父类对象</span><br>        method(()‐&gt;<span class="hljs-built_in">super</span>.sayHello());<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>但是如果使用方法引用来调用父类中的 <code>sayHello</code> 方法会更好，例如另一个子类 <code>Woman</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;大家好,我是Man!&quot;</span>);<br>    &#125; <br><br>    <span class="hljs-comment">// 定义方法method,参数传递Greetable接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Greetable g)</span>&#123;<br>    g.greet();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>    method(<span class="hljs-built_in">super</span>::sayHello);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>() -&gt; super.sayHello()</code></li><li>方法引用： <code>super::sayHello</code></li></ul><h2 id="8-通过this引用成员方法"><a href="#8-通过this引用成员方法" class="headerlink" title="8. 通过this引用成员方法"></a>8. 通过this引用成员方法</h2><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用 <code>this::成员方法</code> 的格式来使用方法引用。首先是简单的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Richable</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>下面是一个丈夫 Husband 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Husband</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">marry</span><span class="hljs-params">(Richable lambda)</span> &#123;<br>        lambda.buy();<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beHappy</span><span class="hljs-params">()</span> &#123;<br>        marry(() ‐&gt; System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>));<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>开心方法 <code>beHappy</code> 调用了结婚方法 <code>marry</code> ，后者的参数为函数式接口 <code>Richable</code> ，所以需要一个Lambda表达式。但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 <code>Husband</code> 丈夫类进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Husband</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buyHouse</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>    &#125; <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">marry</span><span class="hljs-params">(Richable lambda)</span> &#123;<br>    lambda.buy();<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beHappy</span><span class="hljs-params">()</span> &#123;<br>    marry(() ‐&gt; <span class="hljs-built_in">this</span>.buyHouse());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Husband</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buyHouse</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;买套房子&quot;</span>);<br>    &#125; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">marry</span><span class="hljs-params">(Richable lambda)</span> &#123;<br>    lambda.buy();<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beHappy</span><span class="hljs-params">()</span> &#123;<br>    marry(<span class="hljs-built_in">this</span>::buyHouse);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>() -&gt; this.buyHouse()</code></li><li>方法引用： <code>this::buyHouse</code></li></ul><h2 id="9-类的构造器引用"><a href="#9-类的构造器引用" class="headerlink" title="9. 类的构造器引用"></a>9. 类的构造器引用</h2><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 <code>类名称::new</code> 的格式表示。首先是一个简单<br>的 <code>Person</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>然后是用来创建 <code>Person</code> 对象的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonBuilder</span> &#123;<br>Person <span class="hljs-title function_">buildPerson</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用这个函数式接口，可以通过Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo09Lambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">(String name, PersonBuilder builder)</span> &#123;<br>    System.out.println(builder.buildPerson(name).getName());<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    printName(<span class="hljs-string">&quot;赵丽颖&quot;</span>, name ‐&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(name));<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>但是通过构造器引用，有更好的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo10ConstructorRef</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">(String name, PersonBuilder builder)</span> &#123;<br>    System.out.println(builder.buildPerson(name).getName());<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    printName(<span class="hljs-string">&quot;赵丽颖&quot;</span>, Person::<span class="hljs-keyword">new</span>);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>name -&gt; new Person(name)</code></li><li>方法引用： <code>Person::new</code></li></ul><h2 id="10-数组的构造器引用"><a href="#10-数组的构造器引用" class="headerlink" title="10. 数组的构造器引用"></a>10. 数组的构造器引用</h2><p>数组也是 <code>Object</code> 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，<br>需要一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArrayBuilder</span> &#123;<br><span class="hljs-type">int</span>[] buildArray(<span class="hljs-type">int</span> length);<br>&#125; <br></code></pre></td></tr></table></figure><p>在应用该接口的时候，可以通过Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo11ArrayInitRef</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] initArray(<span class="hljs-type">int</span> length, ArrayBuilder builder) &#123;<br>    <span class="hljs-keyword">return</span> builder.buildArray(length);<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = initArray(<span class="hljs-number">10</span>, length ‐&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是更好的写法是使用数组的构造器引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo12ArrayInitRef</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] initArray(<span class="hljs-type">int</span> length, ArrayBuilder builder) &#123;<br>    <span class="hljs-keyword">return</span> builder.buildArray(length);<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = initArray(<span class="hljs-number">10</span>, <span class="hljs-type">int</span>[]::<span class="hljs-keyword">new</span>);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><p>Lambda表达式： <code>length -&gt; new int[length]</code></p><p>方法引用： <code>int[]::new</code></p><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>说到Stream便容易想到I&#x2F;O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的<strong>Stream</strong>概念，用于解决已有集合类库既有的弊端。</p><p>传统集合的多步遍历代码几乎所有的集合（如 <code>Collection</code> 接口或 <code>Map</code> 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01ForEach</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String name : list) &#123;<br>        System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。</p><h3 id="循环遍历的弊端"><a href="#循环遍历的弊端" class="headerlink" title="循环遍历的弊端"></a>循环遍历的弊端</h3><p>Java 8的Lambda让我们可以更加专注于<strong>做什么</strong>（What），而不是<strong>怎么做</strong>（How），这点此前已经结合内部类进行了对比说明。现在，我们仔细体会一下上例代码，可以发现：</p><ul><li>for循环的语法就是“<strong>怎么做</strong>”</li><li>for循环的循环体才是“<strong>做什么</strong>”</li></ul><p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，<strong>而并不是从第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。</p><p>试想一下，如果希望对集合中的元素进行筛选过滤：</p><ol><li>将集合A根据条件一过滤为<strong>子集B</strong>；</li><li>然后再根据条件二过滤为<strong>子集C</strong>。</li></ol><p>那怎么办？在Java 8之前的做法可能为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02NormalFilter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        List&lt;String&gt; zhangList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String name : list) &#123;<br>            <span class="hljs-keyword">if</span> (name.startsWith(<span class="hljs-string">&quot;张&quot;</span>)) &#123;<br>                zhangList.add(name);<br>            &#125;<br>        &#125;<br><br>        List&lt;String&gt; shortList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String name : zhangList) &#123;<br>            <span class="hljs-keyword">if</span> (name.length() == <span class="hljs-number">3</span>) &#123;<br>                shortList.add(name);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (String name : shortList) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  这段代码中含有三个循环，每一个作用不同：</p><ol><li>首先筛选所有姓张的人；</li><li>然后筛选名字有三个字的人；</li><li>最后进行对结果进行打印输出。</li></ol><p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？<strong>不是。</strong>循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。</p><p>那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？</p><h3 id="Stream的更优写法"><a href="#Stream的更优写法" class="headerlink" title="Stream的更优写法"></a>Stream的更优写法</h3><p>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03StreamFilter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        list.stream()<br>            .filter(s ‐&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))<br>            .filter(s ‐&gt; s.length() == <span class="hljs-number">3</span>)<br>            .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p><h2 id="2-流式思想概述"><a href="#2-流式思想概述" class="headerlink" title="2.流式思想概述"></a>2.流式思想概述</h2><p>注意：请暂时忘记对传统IO流的固有印象！</p><p><strong>整体来看，流式思想类似于工厂车间的“</strong>生产流水线”。</p><p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤    方案，然后再按照方案去执行它。这是一种集合元素的处理方案，而方案就是一种“函数模型”。</p><p>这里的 <code>filter 、 map 、 skip</code> 都是在对函数模型进行操作，集合元素<strong>并没有真正被处理</strong>。只有当终结方法 count执行的时候，整个模型才会按照指定策略执行操作。而这得益于<strong>Lambda的延迟执行特性</strong>。</p><blockquote><p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p></blockquote><p>Stream（流）是一个来自数据源的元素队列</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li><strong>数据源</strong> 流的来源。 可以是集合，数组 等。</li></ul><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如**延迟执行(laziness)和短路( short-circuiting)**。</li><li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li></ul><p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。</p><h2 id="3-获取流"><a href="#3-获取流" class="headerlink" title="3.获取流"></a>3.获取流</h2><p><code>java.util.stream.Stream&lt;T&gt;</code> 是Java 8新加入的最常用的流接口（这并不是一个函数式接口）。获取一个流非常简单，有以下几种常用的方式：</p><ul><li><p>所有的 Collection 集合都可以通过 stream 默认方法获取流；</p></li><li><p>Stream 接口的静态方法 of 可以获取数组对应的流。</p></li></ul><h3 id="1-根据Collection获取流"><a href="#1-根据Collection获取流" class="headerlink" title="1.根据Collection获取流"></a>1.根据Collection获取流</h3><p>首先， <code>java.util.Collection</code> 接口中加入了default方法 <code>stream</code> 用来获取流，所以其所有实现类均可获取流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04GetStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        Stream&lt;String&gt; stream1 = list.stream();<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        Stream&lt;String&gt; stream2 = set.stream();<br>        Vector&lt;String&gt; vector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br><br>        Stream&lt;String&gt; stream3 = vector.stream();<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="2-根据Map获取流"><a href="#2-根据Map获取流" class="headerlink" title="2.根据Map获取流"></a>2.根据<strong>Map获取流</strong></h3><p><code>java.util.Map</code> 接口不是 <code>Collection</code> 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05GetStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// ...</span><br>        Stream&lt;String&gt; keyStream = map.keySet().stream();<br>        Stream&lt;String&gt; valueStream = map.values().stream();<br>        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="3-根据数组获取流"><a href="#3-根据数组获取流" class="headerlink" title="3.根据数组获取流"></a>3.<strong>根据数组获取流</strong></h3><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法of ，使用很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06GetStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] array = &#123; <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张翠山&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;张一元&quot;</span> &#125;;<br>        Stream&lt;String&gt; stream = Stream.of(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p></blockquote><h2 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4.常用方法"></a>4.常用方法</h2><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p><ul><li><strong>延迟方法</strong>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。）</li><li><strong>终结方法</strong>：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调用。本小节中，终结方法包括 count 和 forEach 方法。</li></ul><blockquote><p>备注：本小节之外的更多方法，请自行参考API文档。</p></blockquote><h3 id="1-逐一处理：forEach"><a href="#1-逐一处理：forEach" class="headerlink" title="1.逐一处理：forEach"></a>1.逐一处理：<strong>forEach</strong></h3><p>虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span>;<br></code></pre></td></tr></table></figure><p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。</p><h4 id="复习Consumer接口"><a href="#复习Consumer接口" class="headerlink" title="复习Consumer接口"></a><strong>复习Consumer接口</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。<br><br>Consumer接口中包含抽象方法<span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>，意为消费一个指定泛型的数据。<br></code></pre></td></tr></table></figure><h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a><strong>基本使用：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo12StreamForEach</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        stream.forEach(name‐&gt; System.out.println(name));<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="2-过滤：filter"><a href="#2-过滤：filter" class="headerlink" title="2.过滤：filter"></a>2.过滤：filter</h3><p>可以通过 filter 方法将一个流转换成另一个子集流。方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;T&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; predicate)</span>;<br></code></pre></td></tr></table></figure><p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p><h4 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h4><p>此前我们已经学习过 <code>java.util.stream.Predicate</code> 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure><p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的 filter 方法基本使用的代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07StreamFilter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。</p><h3 id="3-映射：map"><a href="#3-映射：map" class="headerlink" title="3.映射：map"></a>3.映射：map</h3><p>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, ? extends R&gt; mapper)</span>;<br></code></pre></td></tr></table></figure><p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><h4 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h4><p>此前我们已经学习过 <code>java.util.stream.Function</code> 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure><p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。</p><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的 map 方法基本使用的代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo08StreamMap</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;18&quot;</span>);<br>        Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str));<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对象）。</p><h3 id="4-统计个数：count"><a href="#4-统计个数：count" class="headerlink" title="4.统计个数：count"></a>4.统计个数：count</h3><p>正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo09StreamCount</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>        System.out.println(result.count()); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="5-取用前几个：limit"><a href="#5-取用前几个：limit" class="headerlink" title="5.取用前几个：limit"></a>5.取用前几个：limit</h3><p>limit 方法可以对流进行截取，只取用前n个。方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;T&gt; <span class="hljs-title function_">limit</span><span class="hljs-params">(<span class="hljs-type">long</span> maxSize)</span>;<br></code></pre></td></tr></table></figure><p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo10StreamLimit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        Stream&lt;String&gt; result = original.limit(<span class="hljs-number">2</span>);<br>        System.out.println(result.count()); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="6-跳过前几个：skip"><a href="#6-跳过前几个：skip" class="headerlink" title="6.跳过前几个：skip"></a>6.跳过前几个：skip</h3><p>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;T&gt; <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>;<br></code></pre></td></tr></table></figure><p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo11StreamSkip</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>        Stream&lt;String&gt; result = original.skip(<span class="hljs-number">2</span>);<br>        System.out.println(result.count()); <span class="hljs-comment">// 1</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="7-组合：concat"><a href="#7-组合：concat" class="headerlink" title="7.组合：concat"></a>7.组合：concat</h3><p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">concat</span><span class="hljs-params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span><br></code></pre></td></tr></table></figure><blockquote><p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p></blockquote><p>该方法的基本使用代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo12StreamConcat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream&lt;String&gt; streamA = Stream.of(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        Stream&lt;String&gt; streamB = Stream.of(<span class="hljs-string">&quot;张翠山&quot;</span>);<br>        Stream&lt;String&gt; result = Stream.concat(streamA, streamB);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>⌨Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(⌨Java) 多线程</title>
    <link href="/2024/06/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/06/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="启动线程的三种方式"><a href="#启动线程的三种方式" class="headerlink" title="启动线程的三种方式"></a>启动线程的三种方式</h2><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><ul><li>子类集成thread类具备多线程能力</li><li>启动线程:子类对象.start()</li><li><strong>不建议使用: 避免oop单继承局限性</strong></li></ul><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><ul><li>实现接口Runnable具有多线程能力</li><li>启动线程: 传入目标对象 + Thread对象,start()</li><li><strong>推荐使用: 避免单继承局限性,灵活方便,方便同一个对象被多个线程使用</strong></li></ul><h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><p>1.实现Callable接口,需要返回值类型</p><p>2.重写call方法,需要抛出异常</p><p>3.创建目标对象</p><p>4.创建执行服务: ExecutorService ser &#x3D; Executors.newFixedThreadPool(1);</p><p>5.提交执行: Future<Boolean> result1 &#x3D; set.submit(t1);</p><p>6.获取结果: bookean r1 &#x3D; result1.get();</p><p>7.关闭服务: ser.shutdownNow();</p><ul><li>可以定义返回值</li><li>可以捕获异常</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ul><li>真实对象和代理对象都要实现同一个接口</li><li>代理对象要使用真实对象的实例</li></ul><p>好处:</p><ul><li>可以增加真实对象</li></ul><p>线程的执行就是使用的静态代理模式</p><p>new Thread(()-&gt;sout(“qweqwe”)).start();</p><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>lambda表达式只能有一行代码的情况下才能简化成为一行,如果有多行,那么就用代码块包裹.</p><p>前提是接口为函数式接口</p><p>多个参数也可以去掉参数类型,要去掉就都去掉,必须加上括号</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><ul><li><p>不推荐使用jdk提供的stop()<br>destroy()方法(已废弃)</p></li><li><p>推荐线程自己停下来</p></li><li><p>建议使用一个标志位进行终止变量</p><p>当flag&#x3D;false,则终止线程运行</p></li></ul><h3 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠sleep</h3><ul><li>sleep(时间)指定当前线程阻塞的毫秒值</li><li>sleep存在异常INterruptedException</li><li>sleep时间达到后线程进入就绪状态</li><li>sleep可以模拟网络延时,倒计时等</li><li>每一个对象都有一个锁,sleep不会释放锁</li><li>使用它可以放大问题的发生性 (模拟延时)</li></ul><h3 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让yield</h3><ul><li>礼让线程,让当前正在执行的线程暂停,但不阻塞</li><li>将线程从运行状态转为就绪状态</li><li>让cpu重新调度,礼让不一定成功</li></ul><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><ul><li>join合并线程,待此线程执行完成后,在执行其他线程,其他线程阻塞</li><li>可以想象成插队</li></ul><h2 id="Thread-State"><a href="#Thread-State" class="headerlink" title="Thread.State"></a>Thread.State</h2><p>线程状态,线程可以处于以下状态之一:</p><ul><li><p>NEW</p><p>尚未启动的线程处于此状态.</p></li><li><p>RUNNABLE</p><p>在java虚拟机中执行的线程处于此状态</p></li><li><p>BLOCKED</p><p>被阻塞等待监视器锁定的线程处于此状态.</p></li><li><p>WATTING</p><p>正在等待另一个线程执行特定动作的线程处于此状态.</p></li><li><p>TIMED_WATTING</p><p>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态.</p></li><li><p>TERMINATED</p><p>已退出的线程处于此状态.</p></li></ul><p>一个线程可以在给定时间点处于一个状态,这些状态是不反映任何操作系统线程状态的虚拟机状态</p><p><img src="/image/postImage/thread_status.png"></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li>java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程,线程调度器按照优先级决定应该调度哪个线程来执行</li><li>线程的优先级用数字表示,范围从1~10<ul><li>Thread.MIN_PRIORITY&#x3D; 1</li><li>Thread.MAX_PRIORITY &#x3D; 10</li><li>Thread.NORM_PRIORITY&#x3D; 5</li></ul></li><li>使用以下方式改变或获取优先级<ul><li>getPriority().setPriority(int xxx)</li></ul></li></ul><h2 id="守护线程-deamon"><a href="#守护线程-deamon" class="headerlink" title="守护线程 deamon"></a>守护线程 deamon</h2><ul><li>线程分为用户线程和守护线程</li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕</li><li>比如,后台记录操作日志,监控内存,垃圾回收等</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li><p>并发: 同一个对象被多个线程同时使用</p></li><li><p>由于同一进程的多个线程共享同一块存储空间,在带来方便的同时,也带来了访问冲突问题,为了保持数据在方法中被访问时的正确性,在访问时加入锁机制synchronized,带那个一个线程获得对象的排它锁,独占资源,其他线程必须等待,使用后释放锁即可,存在以下问题:</p><ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li><li>在多线程竞争下,加锁,释放锁会导致比较多的上下文切换和调度延时,引起性能问题</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁,会导致优先级倒置,引起性能问题</li></ul></li></ul><h2 id="同步方法和同步代码块"><a href="#同步方法和同步代码块" class="headerlink" title="同步方法和同步代码块"></a>同步方法和同步代码块</h2><ul><li><p>犹豫我们可以通过private关键字来保证数据对象只能被方法访问,所以我们只需要针对方法提出一套机制,这套机制就是synchronized关键,它包括两种用法:</p><p>synchronized方法和synchronized块</p><p>同步方法: public synchronized void method(int args){}</p></li><li><p>synchronized方法控制对”对象”的访问,每个对象对应一把锁,每个synchronized方法都必须获得调用该方法的对象的锁才能执行,否则线程会阻塞,方法一旦执行,就独占该锁,直到该方法返回才释放锁,后面被祖泽的线程才能获取这个锁,继续执行</p></li><li><p>缺陷: 若将一个打的方法申明为synchronized将会影响效率</p></li></ul><h4 id="同步方法的弊端"><a href="#同步方法的弊端" class="headerlink" title="同步方法的弊端"></a>同步方法的弊端</h4><ul><li>方法里面需要修改的内容才需要锁,锁的太多,浪费资源</li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><ul><li>同步代码块: synchronized(obj){}</li><li>obj称之为同步监视器<ul><li>obj可以是任何对象,但是推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器,因为同步方法的同步监视器就是this,就是这个对象本身,或者是class[反射]</li></ul></li><li>同步监视器的执行过程<ul><li>第一个线程访问,锁定同步监视器,执行其中代码</li><li>第二个线程访问,发现同步监视器被锁定,无法访问</li><li>第一个线程访问完毕,解锁同步监视器</li><li>第二个线程访问,发现同步监视器没有锁,然后锁定并访问</li></ul></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li><p>多个线程各自占有一些资源,并且相互等待其他线程占有的资源才能运行,而倒置两个或者多个线程都在等待对方释放资源,都停止执行的情形,某一个同步块同时拥有”两个以上对象的锁”时,就可能会发生”死锁”的问题</p></li><li><p>产生死锁的四个必要条件:</p><ul><li>互斥条件: 一个资源每次只能被一个进程使用</li><li>请求与保持条件: 一个进程因请求资源而阻塞时,对已获得的资源保持不放</li><li>不剥夺条件: 进程已获得的资源,在未使用完之前,不能强行剥夺</li><li>循环等待条件: 若干进程之间形成一种头尾项链的循环等待资源关系</li></ul><p>以上条件,只要解决一个或多个就可以避免死锁</p></li></ul><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><ul><li>从jdk1.5开始,java提供了更强大的线程同步机制,通过显示定义同步所对象实现同步,同步所使用Lock对象充当</li><li>java.util.concurrent.locks.Lock接口时控制多个线程对共享资源进行访问的工具.锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁,线程开始访问共享资源之前应先获得Lock对象</li><li>ReentrantLock(可重入锁)类实现了Lock,它拥有与synchronized相同的并发性和内存语义,在实现线程安全的控制中,比较常用的时ReentrantLock,可以显式加锁,释放锁.</li></ul><h4 id="synchronized与Lock的对比"><a href="#synchronized与Lock的对比" class="headerlink" title="synchronized与Lock的对比"></a>synchronized与Lock的对比</h4><ul><li>Lock是显式锁(手动开启和关闭锁)synchronized是隐式锁,出了作用域自动释放搞</li><li>Lock只有代码块锁,synchronized有代码块和方法锁</li><li>使用Lock锁,JVM将花费较少的时间来调度线程,性能更好.并且具有更好的扩展性(提供更多的子类)</li><li>有限使用顺序:<ul><li>Lock &gt; 同步代码块(已经进入方法体,分配了相应资源) &gt;同步方法(在方法体之外)</li></ul></li></ul><h2 id="线程协作-生产者消费者模式"><a href="#线程协作-生产者消费者模式" class="headerlink" title="线程协作(生产者消费者模式)"></a>线程协作(生产者消费者模式)</h2><p>管程法</p><ul><li>利用缓冲区解决</li></ul><p>信号灯法</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>背景: 经常创建和销毁,使用量特别大的资源,比如并发情况下的线程,对性能影响很大.</li><li>思路: 提前创建好多个线程,放入线程池中,使用时直接获取,使用完放回池中.可以避免频繁创建销毁,实现重复利用.类似生活中的公共交通工具.</li><li>好处:<ul><li>提高响速度(减少了创建新线程的时间)</li><li>降低资源消耗(重复利用线程池中线程,不需要每次都创建)</li><li>便于线程管理<ul><li>corePoolSize: 核心池的大小</li><li>maximumPoolSize: 最大线程数</li><li>keepAliveTime: 线程没有任务时最多保持多长时间后会终止</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>⌨Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thread</tag>
      
      <tag>ThreadPool</tag>
      
      <tag>线程池</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(⌨Java) HashMap关键点</title>
    <link href="/2024/06/26/HashMap/"/>
    <url>/2024/06/26/HashMap/</url>
    
    <content type="html"><![CDATA[<h4 id="xxxxxxxxxx-git-config-–global-user-name-“xxx”-配置用户名git-config-–global-user-email-“-120-x78-120-64-120-120-120-46-x63-x6f-x6d-“-配置邮件git-config-–global-color-ui-true-git-status等命令自动着色git-config-–global-color-status-autogit-config-–global-color-diff-autogit-config-–global-color-branch-autogit-config-–global-color-interactive-autogit-config-–global-–unset-http-proxy-remove-proxy-configuration-on-gitgit-clone-git-ssh-x67-x69-116-x40-49-57-x32-46-49-54-56-46-53-x33-x2e-x31-54-56-VT-git-clone远程仓库git-status-查看当前版本状态（是否修改）git-add-xyz-添加xyz文件至indexgit-add-增加当前子目录下所有更改过的文件至indexgit-commit-m-‘xxx’-提交git-commit-–amend-m-‘xxx’-合并上一次提交（用于反复修改）git-commit-am-‘xxx’-将add和commit合为一步git-rm-xxx-删除index中的文件git-rm-r-递归删除git-log-显示提交日志git-log-1-显示1行日志-n为n行git-log-5git-log-–stat-显示提交日志及相关变动文件git-log-p-mgit-show-dfb02e6e4f2f7b573337763e5c0013802e392818-显示某个提交的详细内容git-show-dfb02-可只用commitid的前几位git-show-HEAD-显示HEAD提交日志git-show-HEAD-显示HEAD的父（上一个版本）的提交日志-为上两个版本-5为上5个版本git-tag-显示已存在的taggit-tag-a-v2-0-m-‘xxx’-增加v2-0的taggit-show-v2-0-显示v2-0的日志及详细内容git-log-v2-0-显示v2-0的日志git-diff-显示所有未添加至index的变更git-diff-–cached-显示所有已添加index但还未commit的变更git-diff-HEAD-比较与上一个版本的差异git-diff-HEAD-–-lib-比较与HEAD版本lib目录的差异git-diff-origin-master-master-比较远程分支master上有本地分支master上没有的git-diff-origin-master-master-–stat-只显示差异的文件，不显示具体内容git-remote-add-origin-git-ssh-x67-105-x74-x40-x31-57-50-x2e-x31-x36-x38-x2e-x35-51-46-x31-54-56-VT-git-增加远程定义（用于push-pull-fetch）git-branch-显示本地分支git-branch-–contains-50089-显示包含提交50089的分支git-branch-a-显示所有分支git-branch-r-显示所有原创分支git-branch-–merged-显示所有已合并到当前分支的分支git-branch-–no-merged-显示所有未合并到当前分支的分支git-branch-m-master-master-copy-本地分支改名git-checkout-b-master-copy-从当前分支创建新分支master-copy并检出git-checkout-b-master-master-copy-上面的完整版git-checkout-features-performance-检出已存在的features-performance分支git-checkout-–track-hotfixes-BJVEP933-检出远程分支hotfixes-BJVEP933并创建本地跟踪分支git-checkout-v2-0-检出版本v2-0git-checkout-b-devel-origin-develop-从远程分支develop创建新本地分支devel并检出git-checkout-–-README-检出head版本的README文件（可用于修改错误回退）git-merge-origin-master-合并远程master分支至当前分支git-cherry-pick-ff44785404a8e-合并提交ff44785404a8e的修改git-push-origin-master-将当前分支push到远程master分支git-push-origin-hotfixes-BJVEP933-删除远程仓库的hotfixes-BJVEP933分支git-push-–tags-把所有tag推送到远程仓库git-fetch-获取所有远程分支（不更新本地分支，另需merge）git-fetch-–prune-获取所有原创分支并清除服务器上已删掉的分支git-pull-origin-master-获取远程分支master并merge到当前分支git-mv-README-README2-重命名文件README为README2git-reset-–hard-HEAD-将当前版本重置为HEAD（通常用于merge失败回退）git-rebasegit-branch-d-hotfixes-BJVEP933-删除分支hotfixes-BJVEP933（本分支修改已合并到其他分支）git-branch-D-hotfixes-BJVEP933-强制删除分支hotfixes-BJVEP933git-ls-files-列出git-index包含的文件git-show-branch-图示当前分支历史git-show-branch-–all-图示所有分支历史git-whatchanged-显示提交历史对应的文件修改git-revert-dfb02e6e4f2f7b573337763e5c0013802e392818-撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git-ls-tree-HEAD-内部命令：显示某个git对象git-rev-parse-v2-0-内部命令：显示某个ref对于的SHA1-HASHgit-reflog-显示所有提交，包括孤立节点git-show-HEAD-5-git-show-master-yesterday-显示master分支昨天的状态git-log-–pretty-format-’-h-s’-–graph-图示提交日志git-show-HEAD-3git-show-s-–pretty-raw-2be7fcb476git-stash-暂存当前修改，将所有至为HEAD状态git-stash-list-查看所有暂存git-stash-show-p-stash-0-参考第一次暂存git-stash-apply-stash-0-应用第一次暂存git-grep-“delete-from”-文件中搜索文本“delete-from”git-grep-e-‘-define’-–and-e-SORT-DIRENTgit-gcgit-fsck-git-init-初始化本地git仓库（创建新仓库）​shell"><a href="#xxxxxxxxxx-git-config-–global-user-name-“xxx”-配置用户名git-config-–global-user-email-“-120-x78-120-64-120-120-120-46-x63-x6f-x6d-“-配置邮件git-config-–global-color-ui-true-git-status等命令自动着色git-config-–global-color-status-autogit-config-–global-color-diff-autogit-config-–global-color-branch-autogit-config-–global-color-interactive-autogit-config-–global-–unset-http-proxy-remove-proxy-configuration-on-gitgit-clone-git-ssh-x67-x69-116-x40-49-57-x32-46-49-54-56-46-53-x33-x2e-x31-54-56-VT-git-clone远程仓库git-status-查看当前版本状态（是否修改）git-add-xyz-添加xyz文件至indexgit-add-增加当前子目录下所有更改过的文件至indexgit-commit-m-‘xxx’-提交git-commit-–amend-m-‘xxx’-合并上一次提交（用于反复修改）git-commit-am-‘xxx’-将add和commit合为一步git-rm-xxx-删除index中的文件git-rm-r-递归删除git-log-显示提交日志git-log-1-显示1行日志-n为n行git-log-5git-log-–stat-显示提交日志及相关变动文件git-log-p-mgit-show-dfb02e6e4f2f7b573337763e5c0013802e392818-显示某个提交的详细内容git-show-dfb02-可只用commitid的前几位git-show-HEAD-显示HEAD提交日志git-show-HEAD-显示HEAD的父（上一个版本）的提交日志-为上两个版本-5为上5个版本git-tag-显示已存在的taggit-tag-a-v2-0-m-‘xxx’-增加v2-0的taggit-show-v2-0-显示v2-0的日志及详细内容git-log-v2-0-显示v2-0的日志git-diff-显示所有未添加至index的变更git-diff-–cached-显示所有已添加index但还未commit的变更git-diff-HEAD-比较与上一个版本的差异git-diff-HEAD-–-lib-比较与HEAD版本lib目录的差异git-diff-origin-master-master-比较远程分支master上有本地分支master上没有的git-diff-origin-master-master-–stat-只显示差异的文件，不显示具体内容git-remote-add-origin-git-ssh-x67-105-x74-x40-x31-57-50-x2e-x31-x36-x38-x2e-x35-51-46-x31-54-56-VT-git-增加远程定义（用于push-pull-fetch）git-branch-显示本地分支git-branch-–contains-50089-显示包含提交50089的分支git-branch-a-显示所有分支git-branch-r-显示所有原创分支git-branch-–merged-显示所有已合并到当前分支的分支git-branch-–no-merged-显示所有未合并到当前分支的分支git-branch-m-master-master-copy-本地分支改名git-checkout-b-master-copy-从当前分支创建新分支master-copy并检出git-checkout-b-master-master-copy-上面的完整版git-checkout-features-performance-检出已存在的features-performance分支git-checkout-–track-hotfixes-BJVEP933-检出远程分支hotfixes-BJVEP933并创建本地跟踪分支git-checkout-v2-0-检出版本v2-0git-checkout-b-devel-origin-develop-从远程分支develop创建新本地分支devel并检出git-checkout-–-README-检出head版本的README文件（可用于修改错误回退）git-merge-origin-master-合并远程master分支至当前分支git-cherry-pick-ff44785404a8e-合并提交ff44785404a8e的修改git-push-origin-master-将当前分支push到远程master分支git-push-origin-hotfixes-BJVEP933-删除远程仓库的hotfixes-BJVEP933分支git-push-–tags-把所有tag推送到远程仓库git-fetch-获取所有远程分支（不更新本地分支，另需merge）git-fetch-–prune-获取所有原创分支并清除服务器上已删掉的分支git-pull-origin-master-获取远程分支master并merge到当前分支git-mv-README-README2-重命名文件README为README2git-reset-–hard-HEAD-将当前版本重置为HEAD（通常用于merge失败回退）git-rebasegit-branch-d-hotfixes-BJVEP933-删除分支hotfixes-BJVEP933（本分支修改已合并到其他分支）git-branch-D-hotfixes-BJVEP933-强制删除分支hotfixes-BJVEP933git-ls-files-列出git-index包含的文件git-show-branch-图示当前分支历史git-show-branch-–all-图示所有分支历史git-whatchanged-显示提交历史对应的文件修改git-revert-dfb02e6e4f2f7b573337763e5c0013802e392818-撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git-ls-tree-HEAD-内部命令：显示某个git对象git-rev-parse-v2-0-内部命令：显示某个ref对于的SHA1-HASHgit-reflog-显示所有提交，包括孤立节点git-show-HEAD-5-git-show-master-yesterday-显示master分支昨天的状态git-log-–pretty-format-’-h-s’-–graph-图示提交日志git-show-HEAD-3git-show-s-–pretty-raw-2be7fcb476git-stash-暂存当前修改，将所有至为HEAD状态git-stash-list-查看所有暂存git-stash-show-p-stash-0-参考第一次暂存git-stash-apply-stash-0-应用第一次暂存git-grep-“delete-from”-文件中搜索文本“delete-from”git-grep-e-‘-define’-–and-e-SORT-DIRENTgit-gcgit-fsck-git-init-初始化本地git仓库（创建新仓库）​shell" class="headerlink" title="xxxxxxxxxx git config –global user.name “xxx”                       # 配置用户名git config –global user.email “&#120;&#x78;&#120;&#64;&#120;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;“              # 配置邮件git config –global color.ui true                         # git status等命令自动着色git config –global color.status autogit config –global color.diff autogit config –global color.branch autogit config –global color.interactive autogit config –global –unset http.proxy                    # remove  proxy configuration on gitgit clone git+ssh:&#x2F;&#x2F;&#x67;&#x69;&#116;&#x40;&#49;&#57;&#x32;&#46;&#49;&#54;&#56;&#46;&#53;&#x33;&#x2e;&#x31;&#54;&#56;&#x2F;VT.git             # clone远程仓库git status                                                # 查看当前版本状态（是否修改）git add xyz                                               # 添加xyz文件至indexgit add .                                                 # 增加当前子目录下所有更改过的文件至indexgit commit -m ‘xxx’                                       # 提交git commit –amend -m ‘xxx’                               # 合并上一次提交（用于反复修改）git commit -am ‘xxx’                                      # 将add和commit合为一步git rm xxx                                                # 删除index中的文件git rm -r *                                               # 递归删除git log                                                   # 显示提交日志git log -1                                                # 显示1行日志 -n为n行git log -5git log –stat                                            # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容git show dfb02                                            # 可只用commitid的前几位git show HEAD                                             # 显示HEAD提交日志git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag                                                   # 显示已存在的taggit tag -a v2.0 -m ‘xxx’                                  # 增加v2.0的taggit show v2.0                                             # 显示v2.0的日志及详细内容git log v2.0                                              # 显示v2.0的日志git diff                                                  # 显示所有未添加至index的变更git diff –cached                                         # 显示所有已添加index但还未commit的变更git diff HEAD^                                            # 比较与上一个版本的差异git diff HEAD – .&#x2F;lib                                    # 比较与HEAD版本lib目录的差异git diff origin&#x2F;master..master                            # 比较远程分支master上有本地分支master上没有的git diff origin&#x2F;master..master –stat                     # 只显示差异的文件，不显示具体内容git remote add origin git+ssh:&#x2F;&#x2F;&#x67;&#105;&#x74;&#x40;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x35;&#51;&#46;&#x31;&#54;&#56;&#x2F;VT.git # 增加远程定义（用于push&#x2F;pull&#x2F;fetch）git branch                                                # 显示本地分支git branch –contains 50089                               # 显示包含提交50089的分支git branch -a                                             # 显示所有分支git branch -r                                             # 显示所有原创分支git branch –merged                                       # 显示所有已合并到当前分支的分支git branch –no-merged                                    # 显示所有未合并到当前分支的分支git branch -m master master_copy                          # 本地分支改名git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy                        # 上面的完整版git checkout features&#x2F;performance                         # 检出已存在的features&#x2F;performance分支git checkout –track hotfixes&#x2F;BJVEP933                    # 检出远程分支hotfixes&#x2F;BJVEP933并创建本地跟踪分支git checkout v2.0                                         # 检出版本v2.0git checkout -b devel origin&#x2F;develop                      # 从远程分支develop创建新本地分支devel并检出git checkout – README                                    # 检出head版本的README文件（可用于修改错误回退）git merge origin&#x2F;master                                   # 合并远程master分支至当前分支git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改git push origin master                                    # 将当前分支push到远程master分支git push origin :hotfixes&#x2F;BJVEP933                        # 删除远程仓库的hotfixes&#x2F;BJVEP933分支git push –tags                                           # 把所有tag推送到远程仓库git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）git fetch –prune                                         # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master                                    # 获取远程分支master并merge到当前分支git mv README README2                                     # 重命名文件README为README2git reset –hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes&#x2F;BJVEP933                           # 删除分支hotfixes&#x2F;BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes&#x2F;BJVEP933                           # 强制删除分支hotfixes&#x2F;BJVEP933git ls-files                                              # 列出git index包含的文件git show-branch                                           # 图示当前分支历史git show-branch –all                                     # 图示所有分支历史git whatchanged                                           # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD                                          # 内部命令：显示某个git对象git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASHgit reflog                                                # 显示所有提交，包括孤立节点git show HEAD@{5}git show master@{yesterday}                               # 显示master分支昨天的状态git log –pretty&#x3D;format:’%h %s’ –graph                   # 图示提交日志git show HEAD~3git show -s –pretty&#x3D;raw 2be7fcb476git stash                                                 # 暂存当前修改，将所有至为HEAD状态git stash list                                            # 查看所有暂存git stash show -p stash@{0}                               # 参考第一次暂存git stash apply stash@{0}                                 # 应用第一次暂存git grep “delete from”                                    # 文件中搜索文本“delete from”git grep -e ‘#define’ –and -e SORT_DIRENTgit gcgit fsck git init                                                  # 初始化本地git仓库（创建新仓库）​shell"></a>xxxxxxxxxx git config –global user.name “xxx”                       # 配置用户名git config –global user.email “<a href="mailto:&#120;&#x78;&#120;&#64;&#120;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;">&#120;&#x78;&#120;&#64;&#120;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;</a>“              # 配置邮件git config –global color.ui true                         # git status等命令自动着色git config –global color.status autogit config –global color.diff autogit config –global color.branch autogit config –global color.interactive autogit config –global –unset http.proxy                    # remove  proxy configuration on gitgit clone git+ssh:&#x2F;&#x2F;<a href="mailto:&#x67;&#x69;&#116;&#x40;&#49;&#57;&#x32;&#46;&#49;&#54;&#56;&#46;&#53;&#x33;&#x2e;&#x31;&#54;&#56;">&#x67;&#x69;&#116;&#x40;&#49;&#57;&#x32;&#46;&#49;&#54;&#56;&#46;&#53;&#x33;&#x2e;&#x31;&#54;&#56;</a>&#x2F;VT.git             # clone远程仓库git status                                                # 查看当前版本状态（是否修改）git add xyz                                               # 添加xyz文件至indexgit add .                                                 # 增加当前子目录下所有更改过的文件至indexgit commit -m ‘xxx’                                       # 提交git commit –amend -m ‘xxx’                               # 合并上一次提交（用于反复修改）git commit -am ‘xxx’                                      # 将add和commit合为一步git rm xxx                                                # 删除index中的文件git rm -r *                                               # 递归删除git log                                                   # 显示提交日志git log -1                                                # 显示1行日志 -n为n行git log -5git log –stat                                            # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容git show dfb02                                            # 可只用commitid的前几位git show HEAD                                             # 显示HEAD提交日志git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag                                                   # 显示已存在的taggit tag -a v2.0 -m ‘xxx’                                  # 增加v2.0的taggit show v2.0                                             # 显示v2.0的日志及详细内容git log v2.0                                              # 显示v2.0的日志git diff                                                  # 显示所有未添加至index的变更git diff –cached                                         # 显示所有已添加index但还未commit的变更git diff HEAD^                                            # 比较与上一个版本的差异git diff HEAD – .&#x2F;lib                                    # 比较与HEAD版本lib目录的差异git diff origin&#x2F;master..master                            # 比较远程分支master上有本地分支master上没有的git diff origin&#x2F;master..master –stat                     # 只显示差异的文件，不显示具体内容git remote add origin git+ssh:&#x2F;&#x2F;<a href="mailto:&#x67;&#105;&#x74;&#x40;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x35;&#51;&#46;&#x31;&#54;&#56;">&#x67;&#105;&#x74;&#x40;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x35;&#51;&#46;&#x31;&#54;&#56;</a>&#x2F;VT.git # 增加远程定义（用于push&#x2F;pull&#x2F;fetch）git branch                                                # 显示本地分支git branch –contains 50089                               # 显示包含提交50089的分支git branch -a                                             # 显示所有分支git branch -r                                             # 显示所有原创分支git branch –merged                                       # 显示所有已合并到当前分支的分支git branch –no-merged                                    # 显示所有未合并到当前分支的分支git branch -m master master_copy                          # 本地分支改名git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy                        # 上面的完整版git checkout features&#x2F;performance                         # 检出已存在的features&#x2F;performance分支git checkout –track hotfixes&#x2F;BJVEP933                    # 检出远程分支hotfixes&#x2F;BJVEP933并创建本地跟踪分支git checkout v2.0                                         # 检出版本v2.0git checkout -b devel origin&#x2F;develop                      # 从远程分支develop创建新本地分支devel并检出git checkout – README                                    # 检出head版本的README文件（可用于修改错误回退）git merge origin&#x2F;master                                   # 合并远程master分支至当前分支git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改git push origin master                                    # 将当前分支push到远程master分支git push origin :hotfixes&#x2F;BJVEP933                        # 删除远程仓库的hotfixes&#x2F;BJVEP933分支git push –tags                                           # 把所有tag推送到远程仓库git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）git fetch –prune                                         # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master                                    # 获取远程分支master并merge到当前分支git mv README README2                                     # 重命名文件README为README2git reset –hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes&#x2F;BJVEP933                           # 删除分支hotfixes&#x2F;BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes&#x2F;BJVEP933                           # 强制删除分支hotfixes&#x2F;BJVEP933git ls-files                                              # 列出git index包含的文件git show-branch                                           # 图示当前分支历史git show-branch –all                                     # 图示所有分支历史git whatchanged                                           # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD                                          # 内部命令：显示某个git对象git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASHgit reflog                                                # 显示所有提交，包括孤立节点git show HEAD@{5}git show master@{yesterday}                               # 显示master分支昨天的状态git log –pretty&#x3D;format:’%h %s’ –graph                   # 图示提交日志git show HEAD~3git show -s –pretty&#x3D;raw 2be7fcb476git stash                                                 # 暂存当前修改，将所有至为HEAD状态git stash list                                            # 查看所有暂存git stash show -p stash@{0}                               # 参考第一次暂存git stash apply stash@{0}                                 # 应用第一次暂存git grep “delete from”                                    # 文件中搜索文本“delete from”git grep -e ‘#define’ –and -e SORT_DIRENTgit gcgit fsck git init                                                  # 初始化本地git仓库（创建新仓库）​shell</h4><ul><li>数组加链表组成</li><li>数组中元素是可扩展的链表,数组的初始长度为<strong>16</strong>,负载因子<strong>0.75</strong></li><li>1.7中插入entry是使用<strong>头插法</strong>,1.8之后是使用<strong>尾插法</strong></li><li>1.8版本后的HashMap链表在满意一定条件下会转换成红黑树,便于提高遍历效率<ul><li>数组长度<strong>64</strong>以上,单节点链表长度达到<strong>8</strong>以上</li><li>当红黑树元素少于<strong>6</strong>个时,会再次转换回链表</li></ul></li></ul><h4 id="PUT-GET"><a href="#PUT-GET" class="headerlink" title="PUT GET:"></a>PUT GET:</h4><h6 id="PUT-key-value"><a href="#PUT-key-value" class="headerlink" title="PUT(key,value):"></a>PUT(key,value):</h6><ul><li><p>HashMap中的元素是以键值对保存,每个键值对称为一个<strong>entry</strong></p></li><li><p>在插入元素时,会获取key的HashCode,然后与初始长度进行与运算来确定元素存放在数组的哪个位置</p><blockquote><p> HashCode &amp; (length - 1) &#x3D; index   </p><p> length代表初始长度 index代表数组的存放位置</p></blockquote><p><em><strong>Q:为什么初始长度为16?</strong></em></p><p>A:16-1的二进制表示为<code>1111</code>,在使用HashCode的二进制与运算时,可以控制index值是均匀遍布数组索引,所以初始长度设计为16,map的扩容成两倍扩容也是出于找各种考虑.</p></li><li><p>当然,index也存在重复的情况,比如map中index1位置已经存在元素,而要保存的entry也需要保存到index1位置,此时就会就如下处理:</p><ul><li>1.7版本: 将当前数组位置的元素移动到链表后,将新插入的元素放在链表首位,设计原因是考虑新插入的元素在最近时间内获取的可能性更高,利于查找</li><li>1.8版本: 在当前数组位置的链表中插入在后一位</li></ul></li></ul><h5 id="GET-key"><a href="#GET-key" class="headerlink" title="GET(key)"></a>GET(key)</h5><ul><li>通过key的HashCode通过计算<code>HashCode &amp; (length - 1)</code>位运算的方式获取到index</li><li>通过index找到对应的数组位置<ul><li>如果当前位置只有一个元素,则直接返回</li><li>如果当前位置有链表存在,则逐个遍历,通过key的equal()来判断并找到对应的key,如果找到则返回,否则返回null</li></ul></li></ul><h5 id="转换成红黑树"><a href="#转换成红黑树" class="headerlink" title="转换成红黑树"></a>转换成红黑树</h5><blockquote><p>JDK1.8版本开始,HashMap的结构调整为数组加链表,以及根据元素情况,将链表结构调整为红黑树来提高查找效率</p></blockquote><ul><li>转成红黑树的条件:<ul><li>当前map的容量大于64时,才允许树形化链表</li><li>当链表长度大于8时,才做树形化</li></ul></li><li>转换回红黑树的条件:<ul><li>当进行resize()方法(扩容),此时HashMap会重新计算数据存储位置,当原有红黑树中的元素小于6时,会将树转换成链表</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>⌨Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
