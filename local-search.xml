<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java多线程</title>
    <link href="/2024/06/26/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/06/26/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="启动线程的三种方式"><a href="#启动线程的三种方式" class="headerlink" title="启动线程的三种方式"></a>启动线程的三种方式</h2><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><ul><li>子类集成thread类具备多线程能力</li><li>启动线程:子类对象.start()</li><li><strong>不建议使用: 避免oop单继承局限性</strong></li></ul><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><ul><li>实现接口Runnable具有多线程能力</li><li>启动线程: 传入目标对象 + Thread对象,start()</li><li><strong>推荐使用: 避免单继承局限性,灵活方便,方便同一个对象被多个线程使用</strong></li></ul><h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><p>1.实现Callable接口,需要返回值类型</p><p>2.重写call方法,需要抛出异常</p><p>3.创建目标对象</p><p>4.创建执行服务: ExecutorService ser &#x3D; Executors.newFixedThreadPool(1);</p><p>5.提交执行: Future<Boolean> result1 &#x3D; set.submit(t1);</Boolean></p><p>6.获取结果: bookean r1 &#x3D; result1.get();</p><p>7.关闭服务: ser.shutdownNow();</p><ul><li>可以定义返回值</li><li>可以捕获异常</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ul><li>真实对象和代理对象都要实现同一个接口</li><li>代理对象要使用真实对象的实例</li></ul><p>好处:</p><ul><li>可以增加真实对象</li></ul><p>线程的执行就是使用的静态代理模式</p><p>new Thread(()-&gt;sout(“qweqwe”)).start();</p><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>lambda表达式只能有一行代码的情况下才能简化成为一行,如果有多行,那么就用代码块包裹.</p><p>前提是接口为函数式接口</p><p>多个参数也可以去掉参数类型,要去掉就都去掉,必须加上括号</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><ul><li><p>不推荐使用jdk提供的stop()<br>destroy()方法(已废弃)</p></li><li><p>推荐线程自己停下来</p></li><li><p>建议使用一个标志位进行终止变量</p><p>当flag&#x3D;false,则终止线程运行</p></li></ul><h3 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠sleep</h3><ul><li>sleep(时间)指定当前线程阻塞的毫秒值</li><li>sleep存在异常INterruptedException</li><li>sleep时间达到后线程进入就绪状态</li><li>sleep可以模拟网络延时,倒计时等</li><li>每一个对象都有一个锁,sleep不会释放锁</li><li>使用它可以放大问题的发生性 (模拟延时)</li></ul><h3 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让yield</h3><ul><li>礼让线程,让当前正在执行的线程暂停,但不阻塞</li><li>将线程从运行状态转为就绪状态</li><li>让cpu重新调度,礼让不一定成功</li></ul><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><ul><li>join合并线程,待此线程执行完成后,在执行其他线程,其他线程阻塞</li><li>可以想象成插队</li></ul><h2 id="Thread-State"><a href="#Thread-State" class="headerlink" title="Thread.State"></a>Thread.State</h2><p>线程状态,线程可以处于以下状态之一:</p><ul><li><p>NEW</p><p>尚未启动的线程处于此状态.</p></li><li><p>RUNNABLE</p><p>在java虚拟机中执行的线程处于此状态</p></li><li><p>BLOCKED</p><p>被阻塞等待监视器锁定的线程处于此状态.</p></li><li><p>WATTING</p><p>正在等待另一个线程执行特定动作的线程处于此状态.</p></li><li><p>TIMED_WATTING</p><p>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态.</p></li><li><p>TERMINATED</p><p>已退出的线程处于此状态.</p></li></ul><p>一个线程可以在给定时间点处于一个状态,这些状态是不反映任何操作系统线程状态的虚拟机状态</p><p><img src="/.io//java%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210413114650158.png" alt="image-20210413114650158"></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li>java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程,线程调度器按照优先级决定应该调度哪个线程来执行</li><li>线程的优先级用数字表示,范围从1~10<ul><li>Thread.MIN_PRIORITY&#x3D; 1</li><li>Thread.MAX_PRIORITY &#x3D; 10</li><li>Thread.NORM_PRIORITY&#x3D; 5</li></ul></li><li>使用以下方式改变或获取优先级<ul><li>getPriority().setPriority(int xxx)</li></ul></li></ul><h2 id="守护线程-deamon"><a href="#守护线程-deamon" class="headerlink" title="守护线程 deamon"></a>守护线程 deamon</h2><ul><li>线程分为用户线程和守护线程</li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕</li><li>比如,后台记录操作日志,监控内存,垃圾回收等</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li><p>并发: 同一个对象被多个线程同时使用</p></li><li><p>由于同一进程的多个线程共享同一块存储空间,在带来方便的同时,也带来了访问冲突问题,为了保持数据在方法中被访问时的正确性,在访问时加入锁机制synchronized,带那个一个线程获得对象的排它锁,独占资源,其他线程必须等待,使用后释放锁即可,存在以下问题:</p><ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li><li>在多线程竞争下,加锁,释放锁会导致比较多的上下文切换和调度延时,引起性能问题</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁,会导致优先级倒置,引起性能问题</li></ul></li></ul><h2 id="同步方法和同步代码块"><a href="#同步方法和同步代码块" class="headerlink" title="同步方法和同步代码块"></a>同步方法和同步代码块</h2><ul><li><p>犹豫我们可以通过private关键字来保证数据对象只能被方法访问,所以我们只需要针对方法提出一套机制,这套机制就是synchronized关键,它包括两种用法:</p><p>synchronized方法和synchronized块</p><p>同步方法: public synchronized void method(int args){}</p></li><li><p>synchronized方法控制对”对象”的访问,每个对象对应一把锁,每个synchronized方法都必须获得调用该方法的对象的锁才能执行,否则线程会阻塞,方法一旦执行,就独占该锁,直到该方法返回才释放锁,后面被祖泽的线程才能获取这个锁,继续执行</p></li><li><p>缺陷: 若将一个打的方法申明为synchronized将会影响效率</p></li></ul><h4 id="同步方法的弊端"><a href="#同步方法的弊端" class="headerlink" title="同步方法的弊端"></a>同步方法的弊端</h4><ul><li>方法里面需要修改的内容才需要锁,锁的太多,浪费资源</li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><ul><li>同步代码块: synchronized(obj){}</li><li>obj称之为同步监视器<ul><li>obj可以是任何对象,但是推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器,因为同步方法的同步监视器就是this,就是这个对象本身,或者是class[反射]</li></ul></li><li>同步监视器的执行过程<ul><li>第一个线程访问,锁定同步监视器,执行其中代码</li><li>第二个线程访问,发现同步监视器被锁定,无法访问</li><li>第一个线程访问完毕,解锁同步监视器</li><li>第二个线程访问,发现同步监视器没有锁,然后锁定并访问</li></ul></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li><p>多个线程各自占有一些资源,并且相互等待其他线程占有的资源才能运行,而倒置两个或者多个线程都在等待对方释放资源,都停止执行的情形,某一个同步块同时拥有”两个以上对象的锁”时,就可能会发生”死锁”的问题</p></li><li><p>产生死锁的四个必要条件:</p><ul><li>互斥条件: 一个资源每次只能被一个进程使用</li><li>请求与保持条件: 一个进程因请求资源而阻塞时,对已获得的资源保持不放</li><li>不剥夺条件: 进程已获得的资源,在未使用完之前,不能强行剥夺</li><li>循环等待条件: 若干进程之间形成一种头尾项链的循环等待资源关系</li></ul><p>以上条件,只要解决一个或多个就可以避免死锁</p></li></ul><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><ul><li>从jdk1.5开始,java提供了更强大的线程同步机制,通过显示定义同步所对象实现同步,同步所使用Lock对象充当</li><li>java.util.concurrent.locks.Lock接口时控制多个线程对共享资源进行访问的工具.锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁,线程开始访问共享资源之前应先获得Lock对象</li><li>ReentrantLock(可重入锁)类实现了Lock,它拥有与synchronized相同的并发性和内存语义,在实现线程安全的控制中,比较常用的时ReentrantLock,可以显式加锁,释放锁.</li></ul><h4 id="synchronized与Lock的对比"><a href="#synchronized与Lock的对比" class="headerlink" title="synchronized与Lock的对比"></a>synchronized与Lock的对比</h4><ul><li>Lock是显式锁(手动开启和关闭锁)synchronized是隐式锁,出了作用域自动释放搞</li><li>Lock只有代码块锁,synchronized有代码块和方法锁</li><li>使用Lock锁,JVM将花费较少的时间来调度线程,性能更好.并且具有更好的扩展性(提供更多的子类)</li><li>有限使用顺序:<ul><li>Lock &gt; 同步代码块(已经进入方法体,分配了相应资源) &gt;同步方法(在方法体之外)</li></ul></li></ul><h2 id="线程协作-生产者消费者模式"><a href="#线程协作-生产者消费者模式" class="headerlink" title="线程协作(生产者消费者模式)"></a>线程协作(生产者消费者模式)</h2><p>管程法</p><ul><li>利用缓冲区解决</li></ul><p>信号灯法</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>背景: 经常创建和销毁,使用量特别大的资源,比如并发情况下的线程,对性能影响很大.</li><li>思路: 提前创建好多个线程,放入线程池中,使用时直接获取,使用完放回池中.可以避免频繁创建销毁,实现重复利用.类似生活中的公共交通工具.</li><li>好处:<ul><li>提高响速度(减少了创建新线程的时间)</li><li>降低资源消耗(重复利用线程池中线程,不需要每次都创建)</li><li>便于线程管理<ul><li>corePoolSize: 核心池的大小</li><li>maximumPoolSize: 最大线程数</li><li>keepAliveTime: 线程没有任务时最多保持多长时间后会终止</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hashMap</title>
    <link href="/2024/06/26/hashMap/"/>
    <url>/2024/06/26/hashMap/</url>
    
    <content type="html"><![CDATA[<h4 id="HashMap的结构"><a href="#HashMap的结构" class="headerlink" title="HashMap的结构:"></a>HashMap的结构:</h4><ul><li>数组加链表组成</li><li>数组中元素是可扩展的链表,数组的初始长度为<strong>16</strong>,负载因子<strong>0.75</strong></li><li>1.7中插入entry是使用<strong>头插法</strong>,1.8之后是使用<strong>尾插法</strong></li><li>1.8版本后的HashMap链表在满意一定条件下会转换成红黑树,便于提高遍历效率<ul><li>数组长度<strong>64</strong>以上,单节点链表长度达到<strong>8</strong>以上</li><li>当红黑树元素少于<strong>6</strong>个时,会再次转换回链表</li></ul></li></ul><h4 id="PUT-GET"><a href="#PUT-GET" class="headerlink" title="PUT GET:"></a>PUT GET:</h4><h6 id="PUT-key-value"><a href="#PUT-key-value" class="headerlink" title="PUT(key,value):"></a>PUT(key,value):</h6><ul><li><p>HashMap中的元素是以键值对保存,每个键值对称为一个<strong>entry</strong></p></li><li><p>在插入元素时,会获取key的HashCode,然后与初始长度进行与运算来确定元素存放在数组的哪个位置</p><blockquote><p> HashCode &amp; (length - 1) &#x3D; index   </p><p> length代表初始长度 index代表数组的存放位置</p></blockquote><p><em><strong>Q:为什么初始长度为16?</strong></em></p><p>A:16-1的二进制表示为<code>1111</code>,在使用HashCode的二进制与运算时,可以控制index值是均匀遍布数组索引,所以初始长度设计为16,map的扩容成两倍扩容也是出于找各种考虑.</p></li><li><p>当然,index也存在重复的情况,比如map中index1位置已经存在元素,而要保存的entry也需要保存到index1位置,此时就会就如下处理:</p><ul><li>1.7版本: 将当前数组位置的元素移动到链表后,将新插入的元素放在链表首位,设计原因是考虑新插入的元素在最近时间内获取的可能性更高,利于查找</li><li>1.8版本: 在当前数组位置的链表中插入在后一位</li></ul></li></ul><h5 id="GET-key"><a href="#GET-key" class="headerlink" title="GET(key)"></a>GET(key)</h5><ul><li>通过key的HashCode通过计算<code>HashCode &amp; (length - 1)</code>位运算的方式获取到index</li><li>通过index找到对应的数组位置<ul><li>如果当前位置只有一个元素,则直接返回</li><li>如果当前位置有链表存在,则逐个遍历,通过key的equal()来判断并找到对应的key,如果找到则返回,否则返回null</li></ul></li></ul><h5 id="转换成红黑树"><a href="#转换成红黑树" class="headerlink" title="转换成红黑树"></a>转换成红黑树</h5><blockquote><p>JDK1.8版本开始,HashMap的结构调整为数组加链表,以及根据元素情况,将链表结构调整为红黑树来提高查找效率</p></blockquote><ul><li>转成红黑树的条件:<ul><li>当前map的容量大于64时,才允许树形化链表</li><li>当链表长度大于8时,才做树形化</li></ul></li><li>转换回红黑树的条件:<ul><li>当进行resize()方法(扩容),此时HashMap会重新计算数据存储位置,当原有红黑树中的元素小于6时,会将树转换成链表</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>hashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
